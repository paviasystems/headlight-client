/**
 * HeadlightAPI
 * Pavia Headlight API Server
 *
 * OpenAPI spec version: 0.0.12
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as models from '../model/models';

/* tslint:disable:no-unused-variable member-ordering */

export class ObservationApi {
    protected basePath = 'https://localhost/1.0';
    public defaultHeaders : any = {};

    static $inject: string[] = ['$http', '$httpParamSerializer', 'basePath'];

    constructor(protected $http: ng.IHttpService, protected $httpParamSerializer?: (d: any) => any, basePath?: string) {
        if (basePath !== undefined) {
            this.basePath = basePath;
        }
    }

    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<boolean> {
        const localVarPath = this.basePath + '/Observation/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Index all Observations for a single day (solr)
     * @param SynchronizeByDay 
     */
    public beginIndexByDay (SynchronizeByDay: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/ObservationSearchSyncByDay/{SynchronizeByDay}'
            .replace('{' + 'SynchronizeByDay' + '}', encodeURIComponent(String(SynchronizeByDay)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'SynchronizeByDay' is not null or undefined
        if (SynchronizeByDay === null || SynchronizeByDay === undefined) {
            throw new Error('Required parameter SynchronizeByDay was null or undefined when calling beginIndexByDay.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Index all Observations for a single project (solr)
     * @param IDProject ID of record
     */
    public beginIndexByProject (IDProject: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/ObservationSearchSyncByProject/{IDProject}'
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling beginIndexByProject.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Delete and rebuild entire Observation search index (solr)
     */
    public beginObservationSearchRebuild (extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/ObservationSearchRebuild';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Meadow COUNT
     */
    public count (extraHttpRequestParams?: any ) : ng.IHttpPromise<models.InlineResponse200> {
        const localVarPath = this.basePath + '/Observations/Count';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Meadow PUT (Create)
     * @param body 
     */
    public create (body: models.ObservationModel, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.ObservationModel> {
        const localVarPath = this.basePath + '/Observation';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'PUT',
            url: localVarPath,
            data: body,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param SpritePageNumber 
     * @param IDProject ID of record
     */
    public downloadObservationCollectionImage (SpritePageNumber: number, IDProject: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/Observation/Project/{IDProject}/Sprites/{SpritePageNumber}'
            .replace('{' + 'SpritePageNumber' + '}', encodeURIComponent(String(SpritePageNumber)))
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'SpritePageNumber' is not null or undefined
        if (SpritePageNumber === null || SpritePageNumber === undefined) {
            throw new Error('Required parameter SpritePageNumber was null or undefined when calling downloadObservationCollectionImage.');
        }

        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling downloadObservationCollectionImage.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Download Observation Image - Get transcoded media file for an observation. If not found, asks transcoder to regenerate it
     * @param IDObservation ID of record
     */
    public downloadObservationImage (IDObservation: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/Observation/{IDObservation}/Image/{Size}'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling downloadObservationImage.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Get Observation Image Hash - Get time on observation media item from mongo.
     * @param Size e.g. Thumbnail,Standard,Preview,Enhanced
     * @param Version 
     */
    public getObservationImageHash (Size: string, Version: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/Observation/ImageHash/{Size}/V/{Version}'
            .replace('{' + 'Size' + '}', encodeURIComponent(String(Size)))
            .replace('{' + 'Version' + '}', encodeURIComponent(String(Version)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'Size' is not null or undefined
        if (Size === null || Size === undefined) {
            throw new Error('Required parameter Size was null or undefined when calling getObservationImageHash.');
        }

        // verify required parameter 'Version' is not null or undefined
        if (Version === null || Version === undefined) {
            throw new Error('Required parameter Version was null or undefined when calling getObservationImageHash.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @param SynchronizeFromDate 
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    public getUpdatedObservations (SynchronizeFromDate: Date, Begin: number, Cap: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.BundlesContentManagementObservationModel>> {
        const localVarPath = this.basePath + '/Observations/Sync/{SynchronizeFromDate}/{Begin}/{Cap}'
            .replace('{' + 'SynchronizeFromDate' + '}', encodeURIComponent(String(SynchronizeFromDate)))
            .replace('{' + 'Begin' + '}', encodeURIComponent(String(Begin)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'SynchronizeFromDate' is not null or undefined
        if (SynchronizeFromDate === null || SynchronizeFromDate === undefined) {
            throw new Error('Required parameter SynchronizeFromDate was null or undefined when calling getUpdatedObservations.');
        }

        // verify required parameter 'Begin' is not null or undefined
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling getUpdatedObservations.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getUpdatedObservations.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * postCloneBulkObservations API
     * @param body 
     */
    public postCloneBulkObservations (body: models.ObservationCloneRequest, extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.BundlesContentManagementObservationModel>> {
        const localVarPath = this.basePath + '/Observations/Clone';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postCloneBulkObservations.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: body,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * postCloneObservation API
     * @param IDObservation ID of record
     */
    public postCloneObservation (IDObservation: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.BundlesContentManagementObservationModel> {
        const localVarPath = this.basePath + '/Observation/{IDObservation}/Clone'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling postCloneObservation.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Add a tag to a set of Observations (by ID)
     */
    public postObservationsBatchTagAdd (extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/ObservationsBatchTag/Add';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Remove a tag to a set of Observations (by ID)
     */
    public postObservationsBatchTagRemove (extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/ObservationsBatchTag/Remove';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Index specific Observations (solr)
     * @param IDObservation ID of record
     */
    public pushObservationSearchIndexByIDs (IDObservation: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/ObservationSearchSyncByID/{IDObservation}'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling pushObservationSearchIndexByIDs.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.ObservationModel> {
        const localVarPath = this.basePath + '/Observation/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.ObservationModel>> {
        const localVarPath = this.basePath + '/Observations/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.ObservationModel>> {
        const localVarPath = this.basePath + '/Observations/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Sync Observations  Process (since this is so complex): 1. FOR EACH OBSERVATION     1.1 Archive the Observation     1.2 Merge in the Changes     1.3 Translate the Observation Details     1.4 PERFORM SYNC MATCH AND UPDATE WHERE NECESSARY (TALK TO TRENT)     1.5 After all Detail records are successfully stored, Update Observation so Observation.definition contains the serialized array of Details 2. Get all observation records for this user that have changed since the sync date
     * @param SynchronizeFromDate 
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    public syncObservations (SynchronizeFromDate: Date, Begin: number, Cap: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/Observations/Sync/{SynchronizeFromDate}/{Begin}/{Cap}'
            .replace('{' + 'SynchronizeFromDate' + '}', encodeURIComponent(String(SynchronizeFromDate)))
            .replace('{' + 'Begin' + '}', encodeURIComponent(String(Begin)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'SynchronizeFromDate' is not null or undefined
        if (SynchronizeFromDate === null || SynchronizeFromDate === undefined) {
            throw new Error('Required parameter SynchronizeFromDate was null or undefined when calling syncObservations.');
        }

        // verify required parameter 'Begin' is not null or undefined
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling syncObservations.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling syncObservations.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Touch Observation record UpdateDate and set Transcoded flag - When media files are updated, we want other devices to see the changes and pull it down
     * @param IDObservation ID of record
     */
    public transcodeTouchObservation (IDObservation: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/Observation/{IDObservation}/TranscodeTouch'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling transcodeTouchObservation.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * UNDelete a specific observation
     * @param IDObservation ID of record
     */
    public undeleteObservation (IDObservation: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/Observation/Undelete/{IDObservation}'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling undeleteObservation.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Meadow POST (Update)
     * @param body 
     */
    public update (body: models.ObservationModel, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.ObservationModel> {
        const localVarPath = this.basePath + '/Observation';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: body,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
}
