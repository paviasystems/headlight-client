/**
 * HeadlightAPI
 * Pavia Headlight API Server
 *
 * OpenAPI spec version: 0.0.12
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';


import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DocumentsService {

    protected basePath = 'https://localhost/1.0';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param SynchronizeFromDate FROM date (descending)
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUpdatedDocuments(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getUpdatedDocuments(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getUpdatedDocuments(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getUpdatedDocuments(SynchronizeFromDate: Date, Begin: number, Cap: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (SynchronizeFromDate === null || SynchronizeFromDate === undefined) {
            throw new Error('Required parameter SynchronizeFromDate was null or undefined when calling getUpdatedDocuments.');
        }
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling getUpdatedDocuments.');
        }
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getUpdatedDocuments.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/Documents/${encodeURIComponent(String(SynchronizeFromDate.toISOString()))}/${encodeURIComponent(String(Begin))}/${encodeURIComponent(String(Cap))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Sync Documents  Process (since this is so complex): 1. FOR EACH Document     1.1 Archive the Document     1.2 Merge in the Changes     1.5 After all Detail records are successfully stored, Update Document so Document.definition contains the serialized array of Details 2. Get all Document records for this user that have changed since the sync date
     * @param SynchronizeFromDate FROM date (descending)
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public syncDocuments(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public syncDocuments(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public syncDocuments(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public syncDocuments(SynchronizeFromDate: Date, Begin: number, Cap: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (SynchronizeFromDate === null || SynchronizeFromDate === undefined) {
            throw new Error('Required parameter SynchronizeFromDate was null or undefined when calling syncDocuments.');
        }
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling syncDocuments.');
        }
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling syncDocuments.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/Documents/${encodeURIComponent(String(SynchronizeFromDate.toISOString()))}/${encodeURIComponent(String(Begin))}/${encodeURIComponent(String(Cap))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
