/**
 * HeadlightAPI
 * Pavia Headlight API Server
 *
 * OpenAPI spec version: 0.0.12
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { BundlesContentManagementObservationModel } from '../model/bundlesContentManagementObservationModel';
import { InlineResponse200 } from '../model/inlineResponse200';
import { ObservationCloneRequest } from '../model/observationCloneRequest';
import { ObservationModel } from '../model/observationModel';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ObservationService {

    protected basePath = 'https://localhost/1.0';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * Meadow DELETE
     * @param id ID of record
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public _delete(id: number, observe?: 'body', reportProgress?: boolean): Observable<boolean>;
    public _delete(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<boolean>>;
    public _delete(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<boolean>>;
    public _delete(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<boolean>(`${this.basePath}/Observation/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Index all Observations for a single day (solr)
     * @param SynchronizeByDay 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public beginIndexByDay(SynchronizeByDay: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public beginIndexByDay(SynchronizeByDay: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public beginIndexByDay(SynchronizeByDay: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public beginIndexByDay(SynchronizeByDay: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (SynchronizeByDay === null || SynchronizeByDay === undefined) {
            throw new Error('Required parameter SynchronizeByDay was null or undefined when calling beginIndexByDay.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/ObservationSearchSyncByDay/${encodeURIComponent(String(SynchronizeByDay))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Index all Observations for a single project (solr)
     * @param IDProject ID of record
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public beginIndexByProject(IDProject: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public beginIndexByProject(IDProject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public beginIndexByProject(IDProject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public beginIndexByProject(IDProject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling beginIndexByProject.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/ObservationSearchSyncByProject/${encodeURIComponent(String(IDProject))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Delete and rebuild entire Observation search index (solr)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public beginObservationSearchRebuild(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public beginObservationSearchRebuild(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public beginObservationSearchRebuild(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public beginObservationSearchRebuild(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/ObservationSearchRebuild`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Meadow COUNT
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public count(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;
    public count(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;
    public count(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;
    public count(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<InlineResponse200>(`${this.basePath}/Observations/Count`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Meadow PUT (Create)
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public create(body: ObservationModel, observe?: 'body', reportProgress?: boolean): Observable<ObservationModel>;
    public create(body: ObservationModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ObservationModel>>;
    public create(body: ObservationModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ObservationModel>>;
    public create(body: ObservationModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<ObservationModel>(`${this.basePath}/Observation`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param SpritePageNumber 
     * @param IDProject ID of record
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public downloadObservationCollectionImage(SpritePageNumber: number, IDProject: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public downloadObservationCollectionImage(SpritePageNumber: number, IDProject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public downloadObservationCollectionImage(SpritePageNumber: number, IDProject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public downloadObservationCollectionImage(SpritePageNumber: number, IDProject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (SpritePageNumber === null || SpritePageNumber === undefined) {
            throw new Error('Required parameter SpritePageNumber was null or undefined when calling downloadObservationCollectionImage.');
        }
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling downloadObservationCollectionImage.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/Observation/Project/${encodeURIComponent(String(IDProject))}/Sprites/${encodeURIComponent(String(SpritePageNumber))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Download Observation Image - Get transcoded media file for an observation. If not found, asks transcoder to regenerate it
     * @param IDObservation ID of record
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public downloadObservationImage(IDObservation: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public downloadObservationImage(IDObservation: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public downloadObservationImage(IDObservation: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public downloadObservationImage(IDObservation: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling downloadObservationImage.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/Observation/${encodeURIComponent(String(IDObservation))}/Image/${encodeURIComponent(String(Size))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Get Observation Image Hash - Get time on observation media item from mongo.
     * @param Size e.g. Thumbnail,Standard,Preview,Enhanced
     * @param Version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getObservationImageHash(Size: string, Version: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getObservationImageHash(Size: string, Version: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getObservationImageHash(Size: string, Version: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getObservationImageHash(Size: string, Version: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (Size === null || Size === undefined) {
            throw new Error('Required parameter Size was null or undefined when calling getObservationImageHash.');
        }
        if (Version === null || Version === undefined) {
            throw new Error('Required parameter Version was null or undefined when calling getObservationImageHash.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/Observation/ImageHash/${encodeURIComponent(String(Size))}/V/${encodeURIComponent(String(Version))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param SynchronizeFromDate 
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUpdatedObservations(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'body', reportProgress?: boolean): Observable<Array<BundlesContentManagementObservationModel>>;
    public getUpdatedObservations(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BundlesContentManagementObservationModel>>>;
    public getUpdatedObservations(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BundlesContentManagementObservationModel>>>;
    public getUpdatedObservations(SynchronizeFromDate: Date, Begin: number, Cap: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (SynchronizeFromDate === null || SynchronizeFromDate === undefined) {
            throw new Error('Required parameter SynchronizeFromDate was null or undefined when calling getUpdatedObservations.');
        }
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling getUpdatedObservations.');
        }
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getUpdatedObservations.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BundlesContentManagementObservationModel>>(`${this.basePath}/Observations/Sync/${encodeURIComponent(String(SynchronizeFromDate.toISOString()))}/${encodeURIComponent(String(Begin))}/${encodeURIComponent(String(Cap))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * postCloneBulkObservations API
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postCloneBulkObservations(body: ObservationCloneRequest, observe?: 'body', reportProgress?: boolean): Observable<Array<BundlesContentManagementObservationModel>>;
    public postCloneBulkObservations(body: ObservationCloneRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BundlesContentManagementObservationModel>>>;
    public postCloneBulkObservations(body: ObservationCloneRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BundlesContentManagementObservationModel>>>;
    public postCloneBulkObservations(body: ObservationCloneRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postCloneBulkObservations.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<BundlesContentManagementObservationModel>>(`${this.basePath}/Observations/Clone`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * postCloneObservation API
     * @param IDObservation ID of record
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postCloneObservation(IDObservation: number, observe?: 'body', reportProgress?: boolean): Observable<BundlesContentManagementObservationModel>;
    public postCloneObservation(IDObservation: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BundlesContentManagementObservationModel>>;
    public postCloneObservation(IDObservation: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BundlesContentManagementObservationModel>>;
    public postCloneObservation(IDObservation: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling postCloneObservation.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<BundlesContentManagementObservationModel>(`${this.basePath}/Observation/${encodeURIComponent(String(IDObservation))}/Clone`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Add a tag to a set of Observations (by ID)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postObservationsBatchTagAdd(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postObservationsBatchTagAdd(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postObservationsBatchTagAdd(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postObservationsBatchTagAdd(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/ObservationsBatchTag/Add`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Remove a tag to a set of Observations (by ID)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postObservationsBatchTagRemove(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public postObservationsBatchTagRemove(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public postObservationsBatchTagRemove(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public postObservationsBatchTagRemove(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/ObservationsBatchTag/Remove`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Index specific Observations (solr)
     * @param IDObservation ID of record
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pushObservationSearchIndexByIDs(IDObservation: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public pushObservationSearchIndexByIDs(IDObservation: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public pushObservationSearchIndexByIDs(IDObservation: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public pushObservationSearchIndexByIDs(IDObservation: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling pushObservationSearchIndexByIDs.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/ObservationSearchSyncByID/${encodeURIComponent(String(IDObservation))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Meadow READ
     * @param id ID of record
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public read(id: number, observe?: 'body', reportProgress?: boolean): Observable<ObservationModel>;
    public read(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ObservationModel>>;
    public read(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ObservationModel>>;
    public read(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ObservationModel>(`${this.basePath}/Observation/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public reads(begin: number, max: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ObservationModel>>;
    public reads(begin: number, max: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ObservationModel>>>;
    public reads(begin: number, max: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ObservationModel>>>;
    public reads(begin: number, max: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ObservationModel>>(`${this.basePath}/Observations/${encodeURIComponent(String(begin))}/${encodeURIComponent(String(max))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public readsFiltered(filter: string, begin: number, max: number, observe?: 'body', reportProgress?: boolean): Observable<Array<ObservationModel>>;
    public readsFiltered(filter: string, begin: number, max: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ObservationModel>>>;
    public readsFiltered(filter: string, begin: number, max: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ObservationModel>>>;
    public readsFiltered(filter: string, begin: number, max: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ObservationModel>>(`${this.basePath}/Observations/FilteredTo/${encodeURIComponent(String(filter))}/${encodeURIComponent(String(begin))}/${encodeURIComponent(String(max))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Sync Observations  Process (since this is so complex): 1. FOR EACH OBSERVATION     1.1 Archive the Observation     1.2 Merge in the Changes     1.3 Translate the Observation Details     1.4 PERFORM SYNC MATCH AND UPDATE WHERE NECESSARY (TALK TO TRENT)     1.5 After all Detail records are successfully stored, Update Observation so Observation.definition contains the serialized array of Details 2. Get all observation records for this user that have changed since the sync date
     * @param SynchronizeFromDate 
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public syncObservations(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public syncObservations(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public syncObservations(SynchronizeFromDate: Date, Begin: number, Cap: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public syncObservations(SynchronizeFromDate: Date, Begin: number, Cap: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (SynchronizeFromDate === null || SynchronizeFromDate === undefined) {
            throw new Error('Required parameter SynchronizeFromDate was null or undefined when calling syncObservations.');
        }
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling syncObservations.');
        }
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling syncObservations.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/Observations/Sync/${encodeURIComponent(String(SynchronizeFromDate.toISOString()))}/${encodeURIComponent(String(Begin))}/${encodeURIComponent(String(Cap))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Touch Observation record UpdateDate and set Transcoded flag - When media files are updated, we want other devices to see the changes and pull it down
     * @param IDObservation ID of record
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transcodeTouchObservation(IDObservation: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public transcodeTouchObservation(IDObservation: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public transcodeTouchObservation(IDObservation: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public transcodeTouchObservation(IDObservation: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling transcodeTouchObservation.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/Observation/${encodeURIComponent(String(IDObservation))}/TranscodeTouch`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * UNDelete a specific observation
     * @param IDObservation ID of record
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public undeleteObservation(IDObservation: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public undeleteObservation(IDObservation: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public undeleteObservation(IDObservation: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public undeleteObservation(IDObservation: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling undeleteObservation.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/Observation/Undelete/${encodeURIComponent(String(IDObservation))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Meadow POST (Update)
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public update(body: ObservationModel, observe?: 'body', reportProgress?: boolean): Observable<ObservationModel>;
    public update(body: ObservationModel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ObservationModel>>;
    public update(body: ObservationModel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ObservationModel>>;
    public update(body: ObservationModel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ObservationModel>(`${this.basePath}/Observation`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
