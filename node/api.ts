/**
 * HeadlightAPI
 * Pavia Headlight API Server
 *
 * OpenAPI spec version: 0.0.12
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

const DEFAULT_TIMEOUT = 30 * 1000; //default to 30 second request timeout

let defaultBasePath = 'https://localhost/1.0';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* 
*/
export class Artifact {
    /**
    * 
    */
    'IDArtifact': number;
    /**
    * 
    */
    'GUIDArtifact': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ArtifactType': string;
    /**
    * 
    */
    'Datum': string;
    /**
    * 
    */
    'Version': number;
    /**
    * 
    */
    'Invalid': number;
    /**
    * 
    */
    'IDDevice': number;
    /**
    * 
    */
    'Sync': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDArtifact",
            "baseName": "IDArtifact",
            "type": "number"
        },
        {
            "name": "GUIDArtifact",
            "baseName": "GUIDArtifact",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ArtifactType",
            "baseName": "ArtifactType",
            "type": "string"
        },
        {
            "name": "Datum",
            "baseName": "Datum",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "number"
        },
        {
            "name": "Invalid",
            "baseName": "Invalid",
            "type": "number"
        },
        {
            "name": "IDDevice",
            "baseName": "IDDevice",
            "type": "number"
        },
        {
            "name": "Sync",
            "baseName": "Sync",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Artifact.attributeTypeMap;
    }
}

/**
* 
*/
export class ArtifactModel {
    /**
    * 
    */
    'Datum': any;
    /**
    * 
    */
    'FileName': any;
    /**
    * 
    */
    'IDObservationRequirementSpecification': any;
    /**
    * 
    */
    'IDArtifact': number;
    /**
    * 
    */
    'GUIDArtifact': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ArtifactType': string;
    /**
    * 
    */
    'Version': number;
    /**
    * 
    */
    'Invalid': number;
    /**
    * 
    */
    'IDDevice': number;
    /**
    * 
    */
    'Sync': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Datum",
            "baseName": "Datum",
            "type": "any"
        },
        {
            "name": "FileName",
            "baseName": "FileName",
            "type": "any"
        },
        {
            "name": "IDObservationRequirementSpecification",
            "baseName": "IDObservationRequirementSpecification",
            "type": "any"
        },
        {
            "name": "IDArtifact",
            "baseName": "IDArtifact",
            "type": "number"
        },
        {
            "name": "GUIDArtifact",
            "baseName": "GUIDArtifact",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ArtifactType",
            "baseName": "ArtifactType",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "number"
        },
        {
            "name": "Invalid",
            "baseName": "Invalid",
            "type": "number"
        },
        {
            "name": "IDDevice",
            "baseName": "IDDevice",
            "type": "number"
        },
        {
            "name": "Sync",
            "baseName": "Sync",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ArtifactModel.attributeTypeMap;
    }
}

/**
* 
*/
export class BidItem {
    /**
    * 
    */
    'IDBidItem': number;
    /**
    * 
    */
    'GUIDBidItem': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'IDContract': number;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDPayItem': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDBidItem",
            "baseName": "IDBidItem",
            "type": "number"
        },
        {
            "name": "GUIDBidItem",
            "baseName": "GUIDBidItem",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IDContract",
            "baseName": "IDContract",
            "type": "number"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDPayItem",
            "baseName": "IDPayItem",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return BidItem.attributeTypeMap;
    }
}

/**
* 
*/
export class ChangePasswordRequest {
    /**
    * 
    */
    'NewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "NewPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChangePasswordRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class CommentModel {
    /**
    * 
    */
    'Metadata': any;
    /**
    * 
    */
    'IDComment': number;
    /**
    * 
    */
    'GUIDComment': string;
    /**
    * 
    */
    'IDParent': number;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Comment': string;
    /**
    * 
    */
    'CommentHtml': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Metadata",
            "baseName": "Metadata",
            "type": "any"
        },
        {
            "name": "IDComment",
            "baseName": "IDComment",
            "type": "number"
        },
        {
            "name": "GUIDComment",
            "baseName": "GUIDComment",
            "type": "string"
        },
        {
            "name": "IDParent",
            "baseName": "IDParent",
            "type": "number"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "CommentHtml",
            "baseName": "CommentHtml",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommentModel.attributeTypeMap;
    }
}

/**
* 
*/
export class Contract {
    /**
    * 
    */
    'IDContract': number;
    /**
    * 
    */
    'GUIDContract': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'IDOrganization': number;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'PrimaryProjectNumber': string;
    /**
    * 
    */
    'CountyProjectNumber': string;
    /**
    * 
    */
    'StateProjectNumber': string;
    /**
    * 
    */
    'FederalProjectNumber': string;
    /**
    * 
    */
    'Status': string;
    /**
    * 
    */
    'DBEStructure': string;
    /**
    * 
    */
    'RouteNumber': string;
    /**
    * 
    */
    'HighwayNumber': string;
    /**
    * 
    */
    'PavingMaterial': string;
    /**
    * 
    */
    'StationBegin': string;
    /**
    * 
    */
    'TerminusBegin': string;
    /**
    * 
    */
    'TerminusEnd': string;
    /**
    * 
    */
    'StationEnd': string;
    /**
    * 
    */
    'TotalBidAmount': string;
    /**
    * 
    */
    'NetChangeOrderAmount': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDContract",
            "baseName": "IDContract",
            "type": "number"
        },
        {
            "name": "GUIDContract",
            "baseName": "GUIDContract",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IDOrganization",
            "baseName": "IDOrganization",
            "type": "number"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "PrimaryProjectNumber",
            "baseName": "PrimaryProjectNumber",
            "type": "string"
        },
        {
            "name": "CountyProjectNumber",
            "baseName": "CountyProjectNumber",
            "type": "string"
        },
        {
            "name": "StateProjectNumber",
            "baseName": "StateProjectNumber",
            "type": "string"
        },
        {
            "name": "FederalProjectNumber",
            "baseName": "FederalProjectNumber",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "DBEStructure",
            "baseName": "DBEStructure",
            "type": "string"
        },
        {
            "name": "RouteNumber",
            "baseName": "RouteNumber",
            "type": "string"
        },
        {
            "name": "HighwayNumber",
            "baseName": "HighwayNumber",
            "type": "string"
        },
        {
            "name": "PavingMaterial",
            "baseName": "PavingMaterial",
            "type": "string"
        },
        {
            "name": "StationBegin",
            "baseName": "StationBegin",
            "type": "string"
        },
        {
            "name": "TerminusBegin",
            "baseName": "TerminusBegin",
            "type": "string"
        },
        {
            "name": "TerminusEnd",
            "baseName": "TerminusEnd",
            "type": "string"
        },
        {
            "name": "StationEnd",
            "baseName": "StationEnd",
            "type": "string"
        },
        {
            "name": "TotalBidAmount",
            "baseName": "TotalBidAmount",
            "type": "string"
        },
        {
            "name": "NetChangeOrderAmount",
            "baseName": "NetChangeOrderAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Contract.attributeTypeMap;
    }
}

/**
* 
*/
export class Customer {
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'GUIDCustomer': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Code': string;
    /**
    * 
    */
    'Enabled': number;
    /**
    * 
    */
    'CustomProperties': string;
    /**
    * 
    */
    'Timezone': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "GUIDCustomer",
            "baseName": "GUIDCustomer",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Enabled",
            "baseName": "Enabled",
            "type": "number"
        },
        {
            "name": "CustomProperties",
            "baseName": "CustomProperties",
            "type": "string"
        },
        {
            "name": "Timezone",
            "baseName": "Timezone",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Customer.attributeTypeMap;
    }
}

/**
* 
*/
export class DocumentModel {
    /**
    * 
    */
    'Observations': Array<number>;
    /**
    * 
    */
    'Comments': Array<number>;
    /**
    * 
    */
    'ElectronicSignatures': Array<ElectronicSignature>;
    /**
    * 
    */
    'FormData': any;
    /**
    * 
    */
    'IDDocument': number;
    /**
    * 
    */
    'GUIDDocument': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'DocumentType': string;
    /**
    * 
    */
    'DocumentDate': Date;
    /**
    * 
    */
    'Status': string;
    /**
    * 
    */
    'Version': number;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'IDDevice': number;
    /**
    * 
    */
    'AppHash': string;
    /**
    * 
    */
    'Timezone': string;
    /**
    * 
    */
    'Shift': string;
    /**
    * 
    */
    'StateName': string;
    /**
    * 
    */
    'StateStep': number;
    /**
    * 
    */
    'Locked': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'SequenceNumber': number;
    /**
    * 
    */
    'ExternalSyncGUID': string;
    /**
    * 
    */
    'Form': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Observations",
            "baseName": "Observations",
            "type": "Array<number>"
        },
        {
            "name": "Comments",
            "baseName": "Comments",
            "type": "Array<number>"
        },
        {
            "name": "ElectronicSignatures",
            "baseName": "ElectronicSignatures",
            "type": "Array<ElectronicSignature>"
        },
        {
            "name": "FormData",
            "baseName": "FormData",
            "type": "any"
        },
        {
            "name": "IDDocument",
            "baseName": "IDDocument",
            "type": "number"
        },
        {
            "name": "GUIDDocument",
            "baseName": "GUIDDocument",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "DocumentType",
            "baseName": "DocumentType",
            "type": "string"
        },
        {
            "name": "DocumentDate",
            "baseName": "DocumentDate",
            "type": "Date"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "number"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IDDevice",
            "baseName": "IDDevice",
            "type": "number"
        },
        {
            "name": "AppHash",
            "baseName": "AppHash",
            "type": "string"
        },
        {
            "name": "Timezone",
            "baseName": "Timezone",
            "type": "string"
        },
        {
            "name": "Shift",
            "baseName": "Shift",
            "type": "string"
        },
        {
            "name": "StateName",
            "baseName": "StateName",
            "type": "string"
        },
        {
            "name": "StateStep",
            "baseName": "StateStep",
            "type": "number"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "SequenceNumber",
            "baseName": "SequenceNumber",
            "type": "number"
        },
        {
            "name": "ExternalSyncGUID",
            "baseName": "ExternalSyncGUID",
            "type": "string"
        },
        {
            "name": "Form",
            "baseName": "Form",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DocumentModel.attributeTypeMap;
    }
}

/**
* 
*/
export class DocumentStateChangeRequest {
    /**
    * 
    */
    'IDDocument': number;
    /**
    * 
    */
    'Action': string;
    /**
    * 
    */
    'IDElectronicSignature': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDDocument",
            "baseName": "IDDocument",
            "type": "number"
        },
        {
            "name": "Action",
            "baseName": "Action",
            "type": "string"
        },
        {
            "name": "IDElectronicSignature",
            "baseName": "IDElectronicSignature",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DocumentStateChangeRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class ElectronicSignature {
    /**
    * 
    */
    'IDElectronicSignature': number;
    /**
    * 
    */
    'GUIDElectronicSignature': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Signer': string;
    /**
    * 
    */
    'IDContact': number;
    /**
    * 
    */
    'SignatureType': string;
    /**
    * 
    */
    'IDArtifact': number;
    /**
    * 
    */
    'Approved': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDElectronicSignature",
            "baseName": "IDElectronicSignature",
            "type": "number"
        },
        {
            "name": "GUIDElectronicSignature",
            "baseName": "GUIDElectronicSignature",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Signer",
            "baseName": "Signer",
            "type": "string"
        },
        {
            "name": "IDContact",
            "baseName": "IDContact",
            "type": "number"
        },
        {
            "name": "SignatureType",
            "baseName": "SignatureType",
            "type": "string"
        },
        {
            "name": "IDArtifact",
            "baseName": "IDArtifact",
            "type": "number"
        },
        {
            "name": "Approved",
            "baseName": "Approved",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ElectronicSignature.attributeTypeMap;
    }
}

/**
* 
*/
export class ElectronicSignatureModel {
    /**
    * 
    */
    'Comments': Array<number>;
    /**
    * 
    */
    'IDElectronicSignature': number;
    /**
    * 
    */
    'GUIDElectronicSignature': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Signer': string;
    /**
    * 
    */
    'IDContact': number;
    /**
    * 
    */
    'SignatureType': string;
    /**
    * 
    */
    'IDArtifact': number;
    /**
    * 
    */
    'Approved': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Comments",
            "baseName": "Comments",
            "type": "Array<number>"
        },
        {
            "name": "IDElectronicSignature",
            "baseName": "IDElectronicSignature",
            "type": "number"
        },
        {
            "name": "GUIDElectronicSignature",
            "baseName": "GUIDElectronicSignature",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Signer",
            "baseName": "Signer",
            "type": "string"
        },
        {
            "name": "IDContact",
            "baseName": "IDContact",
            "type": "number"
        },
        {
            "name": "SignatureType",
            "baseName": "SignatureType",
            "type": "string"
        },
        {
            "name": "IDArtifact",
            "baseName": "IDArtifact",
            "type": "number"
        },
        {
            "name": "Approved",
            "baseName": "Approved",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ElectronicSignatureModel.attributeTypeMap;
    }
}

/**
* 
*/
export class Equipment {
    /**
    * 
    */
    'IDEquipment': number;
    /**
    * 
    */
    'GUIDEquipment': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'Notes': string;
    /**
    * 
    */
    'SpecificationYear': number;
    /**
    * 
    */
    'Code': string;
    /**
    * 
    */
    'Status': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDEquipment",
            "baseName": "IDEquipment",
            "type": "number"
        },
        {
            "name": "GUIDEquipment",
            "baseName": "GUIDEquipment",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "SpecificationYear",
            "baseName": "SpecificationYear",
            "type": "number"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Equipment.attributeTypeMap;
    }
}

/**
* 
*/
export class ISession {
    /**
    * 
    */
    'SessionID': string;
    /**
    * 
    */
    'LoggedIn': boolean;
    /**
    * 
    */
    'UserRole': string;
    /**
    * 
    */
    'UserRoleIndex': number;
    /**
    * 
    */
    'UserID': number;
    /**
    * 
    */
    'CustomerID': number;
    /**
    * 
    */
    'Title': string;
    /**
    * 
    */
    'NameFirst': string;
    /**
    * 
    */
    'NameLast': string;
    /**
    * 
    */
    'Email': string;
    /**
    * 
    */
    'LoginID': string;
    /**
    * 
    */
    'UIHash': string;
    /**
    * 
    */
    'Timezone': string;
    /**
    * 
    */
    'Settings': any;
    /**
    * 
    */
    'DeviceID': string;
    /**
    * 
    */
    'IDDevice': number;
    /**
    * 
    */
    'ServerHostURL': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SessionID",
            "baseName": "SessionID",
            "type": "string"
        },
        {
            "name": "LoggedIn",
            "baseName": "LoggedIn",
            "type": "boolean"
        },
        {
            "name": "UserRole",
            "baseName": "UserRole",
            "type": "string"
        },
        {
            "name": "UserRoleIndex",
            "baseName": "UserRoleIndex",
            "type": "number"
        },
        {
            "name": "UserID",
            "baseName": "UserID",
            "type": "number"
        },
        {
            "name": "CustomerID",
            "baseName": "CustomerID",
            "type": "number"
        },
        {
            "name": "Title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "NameFirst",
            "baseName": "NameFirst",
            "type": "string"
        },
        {
            "name": "NameLast",
            "baseName": "NameLast",
            "type": "string"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "LoginID",
            "baseName": "LoginID",
            "type": "string"
        },
        {
            "name": "UIHash",
            "baseName": "UIHash",
            "type": "string"
        },
        {
            "name": "Timezone",
            "baseName": "Timezone",
            "type": "string"
        },
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "any"
        },
        {
            "name": "DeviceID",
            "baseName": "DeviceID",
            "type": "string"
        },
        {
            "name": "IDDevice",
            "baseName": "IDDevice",
            "type": "number"
        },
        {
            "name": "ServerHostURL",
            "baseName": "ServerHostURL",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ISession.attributeTypeMap;
    }
}

export class InlineResponse200 {
    /**
    * 
    */
    'Count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Count",
            "baseName": "Count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200.attributeTypeMap;
    }
}

export class InlineResponse2001 {
    /**
    * 
    */
    'Success'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Success",
            "baseName": "Success",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001.attributeTypeMap;
    }
}

/**
* 
*/
export class Lab {
    /**
    * 
    */
    'IDLab': number;
    /**
    * 
    */
    'GUIDLab': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'IDOrganization': number;
    /**
    * 
    */
    'IDOrganizationAddress': number;
    /**
    * 
    */
    'ExternalOrganization': number;
    /**
    * 
    */
    'Notes': string;
    /**
    * 
    */
    'IDLabParent': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        },
        {
            "name": "GUIDLab",
            "baseName": "GUIDLab",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IDOrganization",
            "baseName": "IDOrganization",
            "type": "number"
        },
        {
            "name": "IDOrganizationAddress",
            "baseName": "IDOrganizationAddress",
            "type": "number"
        },
        {
            "name": "ExternalOrganization",
            "baseName": "ExternalOrganization",
            "type": "number"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "IDLabParent",
            "baseName": "IDLabParent",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Lab.attributeTypeMap;
    }
}

/**
* 
*/
export class LabMaterialAssignment {
    /**
    * 
    */
    'IDLabMaterialAssignment': number;
    /**
    * 
    */
    'GUIDLabMaterialAssignment': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDLab': number;
    /**
    * 
    */
    'IDLabParent': number;
    /**
    * 
    */
    'IDMaterial': number;
    /**
    * 
    */
    'SampleType': string;
    /**
    * 
    */
    'ProductGroup': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDLabMaterialAssignment",
            "baseName": "IDLabMaterialAssignment",
            "type": "number"
        },
        {
            "name": "GUIDLabMaterialAssignment",
            "baseName": "GUIDLabMaterialAssignment",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        },
        {
            "name": "IDLabParent",
            "baseName": "IDLabParent",
            "type": "number"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        },
        {
            "name": "SampleType",
            "baseName": "SampleType",
            "type": "string"
        },
        {
            "name": "ProductGroup",
            "baseName": "ProductGroup",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LabMaterialAssignment.attributeTypeMap;
    }
}

/**
* 
*/
export class LabTestApproval {
    /**
    * 
    */
    'IDLabTestApproval': number;
    /**
    * 
    */
    'GUIDLabTestApproval': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDLab': number;
    /**
    * 
    */
    'IDTest': number;
    /**
    * 
    */
    'DateStart': Date;
    /**
    * 
    */
    'DateEnd': Date;
    /**
    * 
    */
    'Notes': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDLabTestApproval",
            "baseName": "IDLabTestApproval",
            "type": "number"
        },
        {
            "name": "GUIDLabTestApproval",
            "baseName": "GUIDLabTestApproval",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        },
        {
            "name": "IDTest",
            "baseName": "IDTest",
            "type": "number"
        },
        {
            "name": "DateStart",
            "baseName": "DateStart",
            "type": "Date"
        },
        {
            "name": "DateEnd",
            "baseName": "DateEnd",
            "type": "Date"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LabTestApproval.attributeTypeMap;
    }
}

/**
* 
*/
export class LabTestDefault {
    /**
    * 
    */
    'IDLabTestDefault': number;
    /**
    * 
    */
    'GUIDLabTestDefault': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDLab': number;
    /**
    * 
    */
    'IDMaterial': number;
    /**
    * 
    */
    'IDTest': number;
    /**
    * 
    */
    'SampleType': string;
    /**
    * 
    */
    'StartStatus': number;
    /**
    * 
    */
    'RequiredAssign': number;
    /**
    * 
    */
    'Autofinalize': number;
    /**
    * 
    */
    'DefinedTest': number;
    /**
    * 
    */
    'TestRuns': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDLabTestDefault",
            "baseName": "IDLabTestDefault",
            "type": "number"
        },
        {
            "name": "GUIDLabTestDefault",
            "baseName": "GUIDLabTestDefault",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        },
        {
            "name": "IDTest",
            "baseName": "IDTest",
            "type": "number"
        },
        {
            "name": "SampleType",
            "baseName": "SampleType",
            "type": "string"
        },
        {
            "name": "StartStatus",
            "baseName": "StartStatus",
            "type": "number"
        },
        {
            "name": "RequiredAssign",
            "baseName": "RequiredAssign",
            "type": "number"
        },
        {
            "name": "Autofinalize",
            "baseName": "Autofinalize",
            "type": "number"
        },
        {
            "name": "DefinedTest",
            "baseName": "DefinedTest",
            "type": "number"
        },
        {
            "name": "TestRuns",
            "baseName": "TestRuns",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LabTestDefault.attributeTypeMap;
    }
}

/**
* 
*/
export class LineItem {
    /**
    * 
    */
    'IDLineItem': number;
    /**
    * 
    */
    'GUIDLineItem': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'Units': string;
    /**
    * 
    */
    'CostPerUnit': string;
    /**
    * 
    */
    'ExpectedQuantity': string;
    /**
    * 
    */
    'ActualQuantity': string;
    /**
    * 
    */
    'PercentComplete': number;
    /**
    * 
    */
    'IDBidItem': number;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'ContractQuantity': string;
    /**
    * 
    */
    'InstalledQuantity': string;
    /**
    * 
    */
    'Status': string;
    /**
    * 
    */
    'ProposalIdentifier': string;
    /**
    * 
    */
    'Notes': string;
    /**
    * 
    */
    'SpecificationYear': number;
    /**
    * 
    */
    'ItemCode': string;
    /**
    * 
    */
    'ChangeOrderQuantity': string;
    /**
    * 
    */
    'ChangeOrderQuantityPending': string;
    /**
    * 
    */
    'ChangeOrderNumber': string;
    /**
    * 
    */
    'FundingCategory': string;
    /**
    * 
    */
    'CategoryNumber': string;
    /**
    * 
    */
    'Tax': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDLineItem",
            "baseName": "IDLineItem",
            "type": "number"
        },
        {
            "name": "GUIDLineItem",
            "baseName": "GUIDLineItem",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Units",
            "baseName": "Units",
            "type": "string"
        },
        {
            "name": "CostPerUnit",
            "baseName": "CostPerUnit",
            "type": "string"
        },
        {
            "name": "ExpectedQuantity",
            "baseName": "ExpectedQuantity",
            "type": "string"
        },
        {
            "name": "ActualQuantity",
            "baseName": "ActualQuantity",
            "type": "string"
        },
        {
            "name": "PercentComplete",
            "baseName": "PercentComplete",
            "type": "number"
        },
        {
            "name": "IDBidItem",
            "baseName": "IDBidItem",
            "type": "number"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "ContractQuantity",
            "baseName": "ContractQuantity",
            "type": "string"
        },
        {
            "name": "InstalledQuantity",
            "baseName": "InstalledQuantity",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "ProposalIdentifier",
            "baseName": "ProposalIdentifier",
            "type": "string"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "SpecificationYear",
            "baseName": "SpecificationYear",
            "type": "number"
        },
        {
            "name": "ItemCode",
            "baseName": "ItemCode",
            "type": "string"
        },
        {
            "name": "ChangeOrderQuantity",
            "baseName": "ChangeOrderQuantity",
            "type": "string"
        },
        {
            "name": "ChangeOrderQuantityPending",
            "baseName": "ChangeOrderQuantityPending",
            "type": "string"
        },
        {
            "name": "ChangeOrderNumber",
            "baseName": "ChangeOrderNumber",
            "type": "string"
        },
        {
            "name": "FundingCategory",
            "baseName": "FundingCategory",
            "type": "string"
        },
        {
            "name": "CategoryNumber",
            "baseName": "CategoryNumber",
            "type": "string"
        },
        {
            "name": "Tax",
            "baseName": "Tax",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LineItem.attributeTypeMap;
    }
}

/**
* 
*/
export class LoginRequest {
    /**
    * 
    */
    'UserName': string;
    /**
    * 
    */
    'Password': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UserName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LoginRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class MappedArrayArtifact {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MappedArrayArtifact.attributeTypeMap;
    }
}

/**
* 
*/
export class Material {
    /**
    * 
    */
    'IDMaterial': number;
    /**
    * 
    */
    'GUIDMaterial': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'NameAbbreviated': string;
    /**
    * 
    */
    'Type': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'CatalogCode': string;
    /**
    * 
    */
    'UnitsMetric': string;
    /**
    * 
    */
    'UnitsImperial': string;
    /**
    * 
    */
    'Active': number;
    /**
    * 
    */
    'BrandNameRequired': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        },
        {
            "name": "GUIDMaterial",
            "baseName": "GUIDMaterial",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "NameAbbreviated",
            "baseName": "NameAbbreviated",
            "type": "string"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "CatalogCode",
            "baseName": "CatalogCode",
            "type": "string"
        },
        {
            "name": "UnitsMetric",
            "baseName": "UnitsMetric",
            "type": "string"
        },
        {
            "name": "UnitsImperial",
            "baseName": "UnitsImperial",
            "type": "string"
        },
        {
            "name": "Active",
            "baseName": "Active",
            "type": "number"
        },
        {
            "name": "BrandNameRequired",
            "baseName": "BrandNameRequired",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Material.attributeTypeMap;
    }
}

/**
* 
*/
export class MaterialLineItemJoin {
    /**
    * 
    */
    'IDMaterialLineItemJoin': number;
    /**
    * 
    */
    'GUIDMaterialLineItemJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDLineItem': number;
    /**
    * 
    */
    'IDMaterial': number;
    /**
    * 
    */
    'ConversionFactor': string;
    /**
    * 
    */
    'ApprovedSourceRequired': number;
    /**
    * 
    */
    'SpecialInstructions': string;
    /**
    * 
    */
    'Units': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDMaterialLineItemJoin",
            "baseName": "IDMaterialLineItemJoin",
            "type": "number"
        },
        {
            "name": "GUIDMaterialLineItemJoin",
            "baseName": "GUIDMaterialLineItemJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDLineItem",
            "baseName": "IDLineItem",
            "type": "number"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        },
        {
            "name": "ConversionFactor",
            "baseName": "ConversionFactor",
            "type": "string"
        },
        {
            "name": "ApprovedSourceRequired",
            "baseName": "ApprovedSourceRequired",
            "type": "number"
        },
        {
            "name": "SpecialInstructions",
            "baseName": "SpecialInstructions",
            "type": "string"
        },
        {
            "name": "Units",
            "baseName": "Units",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MaterialLineItemJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class MaterialPayItemJoin {
    /**
    * 
    */
    'IDMaterialPayItemJoin': number;
    /**
    * 
    */
    'GUIDMaterialPayItemJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Approved': number;
    /**
    * 
    */
    'IDPayItem': number;
    /**
    * 
    */
    'IDMaterial': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDMaterialPayItemJoin",
            "baseName": "IDMaterialPayItemJoin",
            "type": "number"
        },
        {
            "name": "GUIDMaterialPayItemJoin",
            "baseName": "GUIDMaterialPayItemJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Approved",
            "baseName": "Approved",
            "type": "number"
        },
        {
            "name": "IDPayItem",
            "baseName": "IDPayItem",
            "type": "number"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MaterialPayItemJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class MaterialRecordOfMaterialEntryJoin {
    /**
    * 
    */
    'IDMaterialRecordOfMaterialEntryJoin': number;
    /**
    * 
    */
    'GUIDMaterialRecordOfMaterialEntryJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDMaterial': number;
    /**
    * 
    */
    'IDRecordOfMaterialEntry': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDMaterialRecordOfMaterialEntryJoin",
            "baseName": "IDMaterialRecordOfMaterialEntryJoin",
            "type": "number"
        },
        {
            "name": "GUIDMaterialRecordOfMaterialEntryJoin",
            "baseName": "GUIDMaterialRecordOfMaterialEntryJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        },
        {
            "name": "IDRecordOfMaterialEntry",
            "baseName": "IDRecordOfMaterialEntry",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MaterialRecordOfMaterialEntryJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class MixSpecification {
    /**
    * 
    */
    'IDMixSpecification': number;
    /**
    * 
    */
    'GUIDMixSpecification': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'Code': string;
    /**
    * 
    */
    'MaterialType': string;
    /**
    * 
    */
    'EffectiveDate': Date;
    /**
    * 
    */
    'ExpirationDate': Date;
    /**
    * 
    */
    'ApprovalDate': Date;
    /**
    * 
    */
    'ApprovingIDUser': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDMixSpecification",
            "baseName": "IDMixSpecification",
            "type": "number"
        },
        {
            "name": "GUIDMixSpecification",
            "baseName": "GUIDMixSpecification",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "MaterialType",
            "baseName": "MaterialType",
            "type": "string"
        },
        {
            "name": "EffectiveDate",
            "baseName": "EffectiveDate",
            "type": "Date"
        },
        {
            "name": "ExpirationDate",
            "baseName": "ExpirationDate",
            "type": "Date"
        },
        {
            "name": "ApprovalDate",
            "baseName": "ApprovalDate",
            "type": "Date"
        },
        {
            "name": "ApprovingIDUser",
            "baseName": "ApprovingIDUser",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MixSpecification.attributeTypeMap;
    }
}

/**
* 
*/
export class MixSpecificationMaterialJoin {
    /**
    * 
    */
    'IDMixSpecificationMaterialJoin': number;
    /**
    * 
    */
    'GUIDMixSpecificationMaterialJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDMixSpecification': number;
    /**
    * 
    */
    'IDMaterial': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDMixSpecificationMaterialJoin",
            "baseName": "IDMixSpecificationMaterialJoin",
            "type": "number"
        },
        {
            "name": "GUIDMixSpecificationMaterialJoin",
            "baseName": "GUIDMixSpecificationMaterialJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDMixSpecification",
            "baseName": "IDMixSpecification",
            "type": "number"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MixSpecificationMaterialJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class ModuleModel {
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Settings': any;
    /**
    * 
    */
    'Configuration': any;
    /**
    * 
    */
    'IDModule': number;
    /**
    * 
    */
    'GUIDModule': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Management': number;
    /**
    * 
    */
    'ModuleHash': string;
    /**
    * 
    */
    'Ordinal': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "any"
        },
        {
            "name": "Configuration",
            "baseName": "Configuration",
            "type": "any"
        },
        {
            "name": "IDModule",
            "baseName": "IDModule",
            "type": "number"
        },
        {
            "name": "GUIDModule",
            "baseName": "GUIDModule",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Management",
            "baseName": "Management",
            "type": "number"
        },
        {
            "name": "ModuleHash",
            "baseName": "ModuleHash",
            "type": "string"
        },
        {
            "name": "Ordinal",
            "baseName": "Ordinal",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ModuleModel.attributeTypeMap;
    }
}

/**
* 
*/
export class Notification {
    /**
    * 
    */
    'IDNotification': number;
    /**
    * 
    */
    'GUIDNotification': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'IDNotificationRule': number;
    /**
    * 
    */
    'RecipientIDUser': number;
    /**
    * 
    */
    'NotificationMessage': string;
    /**
    * 
    */
    'Unread': number;
    /**
    * 
    */
    'NotificationType': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDNotification",
            "baseName": "IDNotification",
            "type": "number"
        },
        {
            "name": "GUIDNotification",
            "baseName": "GUIDNotification",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "IDNotificationRule",
            "baseName": "IDNotificationRule",
            "type": "number"
        },
        {
            "name": "RecipientIDUser",
            "baseName": "RecipientIDUser",
            "type": "number"
        },
        {
            "name": "NotificationMessage",
            "baseName": "NotificationMessage",
            "type": "string"
        },
        {
            "name": "Unread",
            "baseName": "Unread",
            "type": "number"
        },
        {
            "name": "NotificationType",
            "baseName": "NotificationType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Notification.attributeTypeMap;
    }
}

/**
* 
*/
export class ObservationArchive {
    /**
    * 
    */
    'IDObservationArchive': number;
    /**
    * 
    */
    'GUIDObservationArchive': string;
    /**
    * 
    */
    'IDObservation': number;
    /**
    * 
    */
    'GUIDObservation': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'IDDevice': number;
    /**
    * 
    */
    'CaptureLatitude': string;
    /**
    * 
    */
    'CaptureLongitude': string;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'Priority': string;
    /**
    * 
    */
    'Tags': string;
    /**
    * 
    */
    'Contractors': string;
    /**
    * 
    */
    'BidItems': string;
    /**
    * 
    */
    'Version': number;
    /**
    * 
    */
    'SpritePage': number;
    /**
    * 
    */
    'DesignatedTime': Date;
    /**
    * 
    */
    'ObservationType': string;
    /**
    * 
    */
    'UserLatitude': string;
    /**
    * 
    */
    'UserLongitude': string;
    /**
    * 
    */
    'AlignmentStation': string;
    /**
    * 
    */
    'AlignmentOffset': string;
    /**
    * 
    */
    'SnapshotJSON': string;
    /**
    * 
    */
    'AppHash': string;
    /**
    * 
    */
    'Locked': number;
    /**
    * 
    */
    'Transcoded': number;
    /**
    * 
    */
    'Status': string;
    /**
    * 
    */
    'StateName': string;
    /**
    * 
    */
    'StateStep': number;
    /**
    * 
    */
    'LineItems': string;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'Equipment': string;
    /**
    * 
    */
    'ExternalSyncGUID': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDObservationArchive",
            "baseName": "IDObservationArchive",
            "type": "number"
        },
        {
            "name": "GUIDObservationArchive",
            "baseName": "GUIDObservationArchive",
            "type": "string"
        },
        {
            "name": "IDObservation",
            "baseName": "IDObservation",
            "type": "number"
        },
        {
            "name": "GUIDObservation",
            "baseName": "GUIDObservation",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IDDevice",
            "baseName": "IDDevice",
            "type": "number"
        },
        {
            "name": "CaptureLatitude",
            "baseName": "CaptureLatitude",
            "type": "string"
        },
        {
            "name": "CaptureLongitude",
            "baseName": "CaptureLongitude",
            "type": "string"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "Priority",
            "baseName": "Priority",
            "type": "string"
        },
        {
            "name": "Tags",
            "baseName": "Tags",
            "type": "string"
        },
        {
            "name": "Contractors",
            "baseName": "Contractors",
            "type": "string"
        },
        {
            "name": "BidItems",
            "baseName": "BidItems",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "number"
        },
        {
            "name": "SpritePage",
            "baseName": "SpritePage",
            "type": "number"
        },
        {
            "name": "DesignatedTime",
            "baseName": "DesignatedTime",
            "type": "Date"
        },
        {
            "name": "ObservationType",
            "baseName": "ObservationType",
            "type": "string"
        },
        {
            "name": "UserLatitude",
            "baseName": "UserLatitude",
            "type": "string"
        },
        {
            "name": "UserLongitude",
            "baseName": "UserLongitude",
            "type": "string"
        },
        {
            "name": "AlignmentStation",
            "baseName": "AlignmentStation",
            "type": "string"
        },
        {
            "name": "AlignmentOffset",
            "baseName": "AlignmentOffset",
            "type": "string"
        },
        {
            "name": "SnapshotJSON",
            "baseName": "SnapshotJSON",
            "type": "string"
        },
        {
            "name": "AppHash",
            "baseName": "AppHash",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "number"
        },
        {
            "name": "Transcoded",
            "baseName": "Transcoded",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "StateName",
            "baseName": "StateName",
            "type": "string"
        },
        {
            "name": "StateStep",
            "baseName": "StateStep",
            "type": "number"
        },
        {
            "name": "LineItems",
            "baseName": "LineItems",
            "type": "string"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "Equipment",
            "baseName": "Equipment",
            "type": "string"
        },
        {
            "name": "ExternalSyncGUID",
            "baseName": "ExternalSyncGUID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ObservationArchive.attributeTypeMap;
    }
}

/**
* 
*/
export class ObservationCloneRequest {
    /**
    * 
    */
    'IDObservations': Array<number>;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'OffsetFromSpecificTime': Date;
    /**
    * 
    */
    'OffsetFromCurrentTime': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDObservations",
            "baseName": "IDObservations",
            "type": "Array<number>"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "OffsetFromSpecificTime",
            "baseName": "OffsetFromSpecificTime",
            "type": "Date"
        },
        {
            "name": "OffsetFromCurrentTime",
            "baseName": "OffsetFromCurrentTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ObservationCloneRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class ObservationFilterRequest {
    /**
    * 
    */
    'SearchText': string;
    'Priority': ObservationFilterRequestPriority;
    /**
    * 
    */
    'ObservationType': Array<string>;
    /**
    * 
    */
    'Contractors': Array<string>;
    'DesignatedTime': ObservationFilterRequestDesignatedTime;
    /**
    * 
    */
    'IDProject': number;
    'DocumentCount': ObservationFilterRequestPriority;
    /**
    * 
    */
    'IDArtifact': Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SearchText",
            "baseName": "SearchText",
            "type": "string"
        },
        {
            "name": "Priority",
            "baseName": "Priority",
            "type": "ObservationFilterRequestPriority"
        },
        {
            "name": "ObservationType",
            "baseName": "ObservationType",
            "type": "Array<string>"
        },
        {
            "name": "Contractors",
            "baseName": "Contractors",
            "type": "Array<string>"
        },
        {
            "name": "DesignatedTime",
            "baseName": "DesignatedTime",
            "type": "ObservationFilterRequestDesignatedTime"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "DocumentCount",
            "baseName": "DocumentCount",
            "type": "ObservationFilterRequestPriority"
        },
        {
            "name": "IDArtifact",
            "baseName": "IDArtifact",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return ObservationFilterRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class ObservationFilterRequestDesignatedTime {
    /**
    * 
    */
    'From'?: Date;
    /**
    * 
    */
    'To'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "From",
            "baseName": "From",
            "type": "Date"
        },
        {
            "name": "To",
            "baseName": "To",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ObservationFilterRequestDesignatedTime.attributeTypeMap;
    }
}

/**
* 
*/
export class ObservationFilterRequestPriority {
    /**
    * 
    */
    'Compare'?: string;
    /**
    * 
    */
    'Value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Compare",
            "baseName": "Compare",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ObservationFilterRequestPriority.attributeTypeMap;
    }
}

/**
* 
*/
export class ObservationModel {
    'Labels': ObservationModelLabels;
    'Details': MappedArrayArtifact;
    /**
    * 
    */
    'Statistics': any;
    /**
    * 
    */
    'IDObservation': number;
    /**
    * 
    */
    'GUIDObservation': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'IDDevice': number;
    /**
    * 
    */
    'CaptureLatitude': string;
    /**
    * 
    */
    'CaptureLongitude': string;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'Priority': string;
    /**
    * 
    */
    'Version': number;
    /**
    * 
    */
    'SpritePage': number;
    /**
    * 
    */
    'DesignatedTime': Date;
    /**
    * 
    */
    'ObservationType': string;
    /**
    * 
    */
    'UserLatitude': string;
    /**
    * 
    */
    'UserLongitude': string;
    /**
    * 
    */
    'AlignmentStation': string;
    /**
    * 
    */
    'AlignmentOffset': string;
    /**
    * 
    */
    'AppHash': string;
    /**
    * 
    */
    'Locked': number;
    /**
    * 
    */
    'Transcoded': number;
    /**
    * 
    */
    'Status': string;
    /**
    * 
    */
    'StateName': string;
    /**
    * 
    */
    'StateStep': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'ExternalSyncGUID': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Labels",
            "baseName": "Labels",
            "type": "ObservationModelLabels"
        },
        {
            "name": "Details",
            "baseName": "Details",
            "type": "MappedArrayArtifact"
        },
        {
            "name": "Statistics",
            "baseName": "Statistics",
            "type": "any"
        },
        {
            "name": "IDObservation",
            "baseName": "IDObservation",
            "type": "number"
        },
        {
            "name": "GUIDObservation",
            "baseName": "GUIDObservation",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "IDDevice",
            "baseName": "IDDevice",
            "type": "number"
        },
        {
            "name": "CaptureLatitude",
            "baseName": "CaptureLatitude",
            "type": "string"
        },
        {
            "name": "CaptureLongitude",
            "baseName": "CaptureLongitude",
            "type": "string"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "Priority",
            "baseName": "Priority",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "number"
        },
        {
            "name": "SpritePage",
            "baseName": "SpritePage",
            "type": "number"
        },
        {
            "name": "DesignatedTime",
            "baseName": "DesignatedTime",
            "type": "Date"
        },
        {
            "name": "ObservationType",
            "baseName": "ObservationType",
            "type": "string"
        },
        {
            "name": "UserLatitude",
            "baseName": "UserLatitude",
            "type": "string"
        },
        {
            "name": "UserLongitude",
            "baseName": "UserLongitude",
            "type": "string"
        },
        {
            "name": "AlignmentStation",
            "baseName": "AlignmentStation",
            "type": "string"
        },
        {
            "name": "AlignmentOffset",
            "baseName": "AlignmentOffset",
            "type": "string"
        },
        {
            "name": "AppHash",
            "baseName": "AppHash",
            "type": "string"
        },
        {
            "name": "Locked",
            "baseName": "Locked",
            "type": "number"
        },
        {
            "name": "Transcoded",
            "baseName": "Transcoded",
            "type": "number"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "StateName",
            "baseName": "StateName",
            "type": "string"
        },
        {
            "name": "StateStep",
            "baseName": "StateStep",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "ExternalSyncGUID",
            "baseName": "ExternalSyncGUID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ObservationModel.attributeTypeMap;
    }
}

/**
* 
*/
export class ObservationModelLabels {
    /**
    * 
    */
    'SAVE'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "SAVE",
            "baseName": "SAVE",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ObservationModelLabels.attributeTypeMap;
    }
}

/**
* 
*/
export class Organization {
    /**
    * 
    */
    'IDOrganization': number;
    /**
    * 
    */
    'GUIDOrganization': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'DisadvantagedBusiness': number;
    /**
    * 
    */
    'Address': string;
    /**
    * 
    */
    'City': string;
    /**
    * 
    */
    'State': string;
    /**
    * 
    */
    'Zip': string;
    /**
    * 
    */
    'Phone': string;
    /**
    * 
    */
    'Approved': number;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'Email': string;
    /**
    * 
    */
    'Type': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDOrganization",
            "baseName": "IDOrganization",
            "type": "number"
        },
        {
            "name": "GUIDOrganization",
            "baseName": "GUIDOrganization",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "DisadvantagedBusiness",
            "baseName": "DisadvantagedBusiness",
            "type": "number"
        },
        {
            "name": "Address",
            "baseName": "Address",
            "type": "string"
        },
        {
            "name": "City",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "State",
            "baseName": "State",
            "type": "string"
        },
        {
            "name": "Zip",
            "baseName": "Zip",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "Approved",
            "baseName": "Approved",
            "type": "number"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Organization.attributeTypeMap;
    }
}

/**
* 
*/
export class OrganizationMaterialJoin {
    /**
    * 
    */
    'IDOrganizationMaterialJoin': number;
    /**
    * 
    */
    'GUIDOrganizationMaterialJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDOrganization': number;
    /**
    * 
    */
    'IDMaterial': number;
    /**
    * 
    */
    'EffectiveDate': Date;
    /**
    * 
    */
    'ExpirationDate': Date;
    /**
    * 
    */
    'ApprovedStatusType': string;
    /**
    * 
    */
    'SourceType': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDOrganizationMaterialJoin",
            "baseName": "IDOrganizationMaterialJoin",
            "type": "number"
        },
        {
            "name": "GUIDOrganizationMaterialJoin",
            "baseName": "GUIDOrganizationMaterialJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDOrganization",
            "baseName": "IDOrganization",
            "type": "number"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        },
        {
            "name": "EffectiveDate",
            "baseName": "EffectiveDate",
            "type": "Date"
        },
        {
            "name": "ExpirationDate",
            "baseName": "ExpirationDate",
            "type": "Date"
        },
        {
            "name": "ApprovedStatusType",
            "baseName": "ApprovedStatusType",
            "type": "string"
        },
        {
            "name": "SourceType",
            "baseName": "SourceType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrganizationMaterialJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class PayItemModel {
    /**
    * 
    */
    'Extended': any;
    /**
    * 
    */
    'IDPayItem': number;
    /**
    * 
    */
    'GUIDPayItem': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'Units': string;
    /**
    * 
    */
    'Amount': string;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Extended",
            "baseName": "Extended",
            "type": "any"
        },
        {
            "name": "IDPayItem",
            "baseName": "IDPayItem",
            "type": "number"
        },
        {
            "name": "GUIDPayItem",
            "baseName": "GUIDPayItem",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Units",
            "baseName": "Units",
            "type": "string"
        },
        {
            "name": "Amount",
            "baseName": "Amount",
            "type": "string"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PayItemModel.attributeTypeMap;
    }
}

/**
* 
*/
export class Product {
    /**
    * 
    */
    'IDProduct': number;
    /**
    * 
    */
    'GUIDProduct': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'ManufacturerCode': string;
    /**
    * 
    */
    'AcceptanceMethod': string;
    /**
    * 
    */
    'ProductCategory': string;
    /**
    * 
    */
    'CatalogCode': string;
    /**
    * 
    */
    'EffectiveDate': Date;
    /**
    * 
    */
    'ExpirationDate': Date;
    /**
    * 
    */
    'Comments': string;
    /**
    * 
    */
    'IDMaterial': number;
    /**
    * 
    */
    'IDOrganization': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDProduct",
            "baseName": "IDProduct",
            "type": "number"
        },
        {
            "name": "GUIDProduct",
            "baseName": "GUIDProduct",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "ManufacturerCode",
            "baseName": "ManufacturerCode",
            "type": "string"
        },
        {
            "name": "AcceptanceMethod",
            "baseName": "AcceptanceMethod",
            "type": "string"
        },
        {
            "name": "ProductCategory",
            "baseName": "ProductCategory",
            "type": "string"
        },
        {
            "name": "CatalogCode",
            "baseName": "CatalogCode",
            "type": "string"
        },
        {
            "name": "EffectiveDate",
            "baseName": "EffectiveDate",
            "type": "Date"
        },
        {
            "name": "ExpirationDate",
            "baseName": "ExpirationDate",
            "type": "Date"
        },
        {
            "name": "Comments",
            "baseName": "Comments",
            "type": "string"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        },
        {
            "name": "IDOrganization",
            "baseName": "IDOrganization",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Product.attributeTypeMap;
    }
}

/**
* 
*/
export class ProductionPlant {
    /**
    * 
    */
    'IDProductionPlant': number;
    /**
    * 
    */
    'GUIDProductionPlant': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'IDOrganization': number;
    /**
    * 
    */
    'IDOrganizationAddress': number;
    /**
    * 
    */
    'Notes': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDProductionPlant",
            "baseName": "IDProductionPlant",
            "type": "number"
        },
        {
            "name": "GUIDProductionPlant",
            "baseName": "GUIDProductionPlant",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IDOrganization",
            "baseName": "IDOrganization",
            "type": "number"
        },
        {
            "name": "IDOrganizationAddress",
            "baseName": "IDOrganizationAddress",
            "type": "number"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProductionPlant.attributeTypeMap;
    }
}

/**
* 
*/
export class ProductionPlantMaterialApproval {
    /**
    * 
    */
    'IDProductionPlantMaterialApproval': number;
    /**
    * 
    */
    'GUIDProductionPlantMaterialApproval': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDMaterial': number;
    /**
    * 
    */
    'IDMixSpecification': number;
    /**
    * 
    */
    'IDProductionPlant': number;
    /**
    * 
    */
    'StartDate': Date;
    /**
    * 
    */
    'EndDate': Date;
    /**
    * 
    */
    'Notes': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDProductionPlantMaterialApproval",
            "baseName": "IDProductionPlantMaterialApproval",
            "type": "number"
        },
        {
            "name": "GUIDProductionPlantMaterialApproval",
            "baseName": "GUIDProductionPlantMaterialApproval",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        },
        {
            "name": "IDMixSpecification",
            "baseName": "IDMixSpecification",
            "type": "number"
        },
        {
            "name": "IDProductionPlant",
            "baseName": "IDProductionPlant",
            "type": "number"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "EndDate",
            "baseName": "EndDate",
            "type": "Date"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProductionPlantMaterialApproval.attributeTypeMap;
    }
}

/**
* 
*/
export class ProjectModel {
    /**
    * 
    */
    'Tags': Array<string>;
    /**
    * 
    */
    'BidItems': Array<string>;
    /**
    * 
    */
    'LineItems': Array<string>;
    /**
    * 
    */
    'Contractors': Array<string>;
    /**
    * 
    */
    'TagTypes': Array<string>;
    /**
    * 
    */
    'LabelTypes': any;
    /**
    * 
    */
    'CustomProperties': any;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'GUIDProject': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Latitude': string;
    /**
    * 
    */
    'Longitude': string;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDContract': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'Timezone': string;
    /**
    * 
    */
    'Status': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Tags",
            "baseName": "Tags",
            "type": "Array<string>"
        },
        {
            "name": "BidItems",
            "baseName": "BidItems",
            "type": "Array<string>"
        },
        {
            "name": "LineItems",
            "baseName": "LineItems",
            "type": "Array<string>"
        },
        {
            "name": "Contractors",
            "baseName": "Contractors",
            "type": "Array<string>"
        },
        {
            "name": "TagTypes",
            "baseName": "TagTypes",
            "type": "Array<string>"
        },
        {
            "name": "LabelTypes",
            "baseName": "LabelTypes",
            "type": "any"
        },
        {
            "name": "CustomProperties",
            "baseName": "CustomProperties",
            "type": "any"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "GUIDProject",
            "baseName": "GUIDProject",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Latitude",
            "baseName": "Latitude",
            "type": "string"
        },
        {
            "name": "Longitude",
            "baseName": "Longitude",
            "type": "string"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDContract",
            "baseName": "IDContract",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "Timezone",
            "baseName": "Timezone",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProjectModel.attributeTypeMap;
    }
}

/**
* 
*/
export class QueryRequest {
    /**
    * 
    */
    'Filters': Array<any>;
    /**
    * 
    */
    'SelectFields': Array<any>;
    /**
    * 
    */
    'Joins': Array<any>;
    /**
    * 
    */
    'SortFields': Array<any>;
    /**
    * 
    */
    'Begin': number;
    /**
    * 
    */
    'Cap': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Filters",
            "baseName": "Filters",
            "type": "Array<any>"
        },
        {
            "name": "SelectFields",
            "baseName": "SelectFields",
            "type": "Array<any>"
        },
        {
            "name": "Joins",
            "baseName": "Joins",
            "type": "Array<any>"
        },
        {
            "name": "SortFields",
            "baseName": "SortFields",
            "type": "Array<any>"
        },
        {
            "name": "Begin",
            "baseName": "Begin",
            "type": "number"
        },
        {
            "name": "Cap",
            "baseName": "Cap",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return QueryRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class RecordOfMaterial {
    /**
    * 
    */
    'IDRecordOfMaterial': number;
    /**
    * 
    */
    'GUIDRecordOfMaterial': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'Notes': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDRecordOfMaterial",
            "baseName": "IDRecordOfMaterial",
            "type": "number"
        },
        {
            "name": "GUIDRecordOfMaterial",
            "baseName": "GUIDRecordOfMaterial",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RecordOfMaterial.attributeTypeMap;
    }
}

/**
* 
*/
export class RecordOfMaterialEntry {
    /**
    * 
    */
    'IDRecordOfMaterialEntry': number;
    /**
    * 
    */
    'GUIDRecordOfMaterialEntry': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'IDRecordOfMaterial': number;
    /**
    * 
    */
    'IDBidItem': number;
    /**
    * 
    */
    'IDLineItem': number;
    /**
    * 
    */
    'Notes': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDRecordOfMaterialEntry",
            "baseName": "IDRecordOfMaterialEntry",
            "type": "number"
        },
        {
            "name": "GUIDRecordOfMaterialEntry",
            "baseName": "GUIDRecordOfMaterialEntry",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "IDRecordOfMaterial",
            "baseName": "IDRecordOfMaterial",
            "type": "number"
        },
        {
            "name": "IDBidItem",
            "baseName": "IDBidItem",
            "type": "number"
        },
        {
            "name": "IDLineItem",
            "baseName": "IDLineItem",
            "type": "number"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RecordOfMaterialEntry.attributeTypeMap;
    }
}

/**
* 
*/
export class RecordOfMaterialEntryArchive {
    /**
    * 
    */
    'IDRecordOfMaterialEntryArchive': number;
    /**
    * 
    */
    'GUIDRecordOfMaterialEntryArchive': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDRecordOfMaterialEntry': number;
    /**
    * 
    */
    'RecordOfMaterialEntry': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDRecordOfMaterialEntryArchive",
            "baseName": "IDRecordOfMaterialEntryArchive",
            "type": "number"
        },
        {
            "name": "GUIDRecordOfMaterialEntryArchive",
            "baseName": "GUIDRecordOfMaterialEntryArchive",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDRecordOfMaterialEntry",
            "baseName": "IDRecordOfMaterialEntry",
            "type": "number"
        },
        {
            "name": "RecordOfMaterialEntry",
            "baseName": "RecordOfMaterialEntry",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RecordOfMaterialEntryArchive.attributeTypeMap;
    }
}

/**
* 
*/
export class ReportModel {
    /**
    * 
    */
    'Options': any;
    /**
    * 
    */
    'IDReportArchetype': number;
    /**
    * 
    */
    'GUIDReportArchetype': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Archetype': string;
    /**
    * 
    */
    'IDCustomer': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Options",
            "baseName": "Options",
            "type": "any"
        },
        {
            "name": "IDReportArchetype",
            "baseName": "IDReportArchetype",
            "type": "number"
        },
        {
            "name": "GUIDReportArchetype",
            "baseName": "GUIDReportArchetype",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Archetype",
            "baseName": "Archetype",
            "type": "string"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ReportModel.attributeTypeMap;
    }
}

/**
* 
*/
export class ReportNamedInstanceModel {
    /**
    * 
    */
    'Archetype': string;
    /**
    * 
    */
    'Options': any;
    /**
    * 
    */
    'IDReportNamedInstance': number;
    /**
    * 
    */
    'GUIDReportNamedInstance': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Hash': string;
    /**
    * 
    */
    'OptionsJSON': string;
    /**
    * 
    */
    'IDReportArchetype': number;
    /**
    * 
    */
    'IDCustomer': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Archetype",
            "baseName": "Archetype",
            "type": "string"
        },
        {
            "name": "Options",
            "baseName": "Options",
            "type": "any"
        },
        {
            "name": "IDReportNamedInstance",
            "baseName": "IDReportNamedInstance",
            "type": "number"
        },
        {
            "name": "GUIDReportNamedInstance",
            "baseName": "GUIDReportNamedInstance",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Hash",
            "baseName": "Hash",
            "type": "string"
        },
        {
            "name": "OptionsJSON",
            "baseName": "OptionsJSON",
            "type": "string"
        },
        {
            "name": "IDReportArchetype",
            "baseName": "IDReportArchetype",
            "type": "number"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ReportNamedInstanceModel.attributeTypeMap;
    }
}

/**
* 
*/
export class ReportRenderResult {
    /**
    * UUID of rendered report.
    */
    'GUIDReportDescription': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "GUIDReportDescription",
            "baseName": "GUIDReportDescription",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportRenderResult.attributeTypeMap;
    }
}

/**
* 
*/
export class Sample {
    /**
    * 
    */
    'IDSample': number;
    /**
    * 
    */
    'GUIDSample': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'QRCode': string;
    /**
    * 
    */
    'CaptureLatitude': string;
    /**
    * 
    */
    'CaptureLongitude': string;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'ParentIDSample': number;
    /**
    * 
    */
    'IDMaterial': number;
    /**
    * 
    */
    'Notes': string;
    /**
    * 
    */
    'IDProductionPlant': number;
    /**
    * 
    */
    'IDLineItem': number;
    /**
    * 
    */
    'RepresentedQuantityUnits': string;
    /**
    * 
    */
    'SampledQuantityUnits': string;
    /**
    * 
    */
    'LabControlNumber': string;
    /**
    * 
    */
    'LabReferenceNumber': string;
    /**
    * 
    */
    'ProductName': string;
    /**
    * 
    */
    'MaterialType': string;
    /**
    * 
    */
    'IDOrganization': number;
    /**
    * 
    */
    'IDMixDesign': number;
    /**
    * 
    */
    'ManufacturerCode': string;
    /**
    * 
    */
    'IntendedUse': string;
    /**
    * 
    */
    'BuyUSA': number;
    /**
    * 
    */
    'ReceivedFrom': string;
    /**
    * 
    */
    'GeographicalArea': string;
    /**
    * 
    */
    'Station': string;
    /**
    * 
    */
    'Offset': string;
    /**
    * 
    */
    'RepresentedQuantity': string;
    /**
    * 
    */
    'SampledQuantity': string;
    /**
    * 
    */
    'Units': string;
    /**
    * 
    */
    'RequestedBy': string;
    /**
    * 
    */
    'Status': string;
    /**
    * 
    */
    'ExternalSyncGUID': string;
    /**
    * 
    */
    'IDLab': number;
    /**
    * 
    */
    'IDProduct': number;
    /**
    * 
    */
    'SampledByIDUser': number;
    /**
    * 
    */
    'WitnessIDUser': number;
    /**
    * 
    */
    'AuthorizedIDUser': number;
    /**
    * 
    */
    'CMSIDUser': number;
    /**
    * 
    */
    'Datum': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDSample",
            "baseName": "IDSample",
            "type": "number"
        },
        {
            "name": "GUIDSample",
            "baseName": "GUIDSample",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "QRCode",
            "baseName": "QRCode",
            "type": "string"
        },
        {
            "name": "CaptureLatitude",
            "baseName": "CaptureLatitude",
            "type": "string"
        },
        {
            "name": "CaptureLongitude",
            "baseName": "CaptureLongitude",
            "type": "string"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "ParentIDSample",
            "baseName": "ParentIDSample",
            "type": "number"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "IDProductionPlant",
            "baseName": "IDProductionPlant",
            "type": "number"
        },
        {
            "name": "IDLineItem",
            "baseName": "IDLineItem",
            "type": "number"
        },
        {
            "name": "RepresentedQuantityUnits",
            "baseName": "RepresentedQuantityUnits",
            "type": "string"
        },
        {
            "name": "SampledQuantityUnits",
            "baseName": "SampledQuantityUnits",
            "type": "string"
        },
        {
            "name": "LabControlNumber",
            "baseName": "LabControlNumber",
            "type": "string"
        },
        {
            "name": "LabReferenceNumber",
            "baseName": "LabReferenceNumber",
            "type": "string"
        },
        {
            "name": "ProductName",
            "baseName": "ProductName",
            "type": "string"
        },
        {
            "name": "MaterialType",
            "baseName": "MaterialType",
            "type": "string"
        },
        {
            "name": "IDOrganization",
            "baseName": "IDOrganization",
            "type": "number"
        },
        {
            "name": "IDMixDesign",
            "baseName": "IDMixDesign",
            "type": "number"
        },
        {
            "name": "ManufacturerCode",
            "baseName": "ManufacturerCode",
            "type": "string"
        },
        {
            "name": "IntendedUse",
            "baseName": "IntendedUse",
            "type": "string"
        },
        {
            "name": "BuyUSA",
            "baseName": "BuyUSA",
            "type": "number"
        },
        {
            "name": "ReceivedFrom",
            "baseName": "ReceivedFrom",
            "type": "string"
        },
        {
            "name": "GeographicalArea",
            "baseName": "GeographicalArea",
            "type": "string"
        },
        {
            "name": "Station",
            "baseName": "Station",
            "type": "string"
        },
        {
            "name": "Offset",
            "baseName": "Offset",
            "type": "string"
        },
        {
            "name": "RepresentedQuantity",
            "baseName": "RepresentedQuantity",
            "type": "string"
        },
        {
            "name": "SampledQuantity",
            "baseName": "SampledQuantity",
            "type": "string"
        },
        {
            "name": "Units",
            "baseName": "Units",
            "type": "string"
        },
        {
            "name": "RequestedBy",
            "baseName": "RequestedBy",
            "type": "string"
        },
        {
            "name": "Status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "ExternalSyncGUID",
            "baseName": "ExternalSyncGUID",
            "type": "string"
        },
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        },
        {
            "name": "IDProduct",
            "baseName": "IDProduct",
            "type": "number"
        },
        {
            "name": "SampledByIDUser",
            "baseName": "SampledByIDUser",
            "type": "number"
        },
        {
            "name": "WitnessIDUser",
            "baseName": "WitnessIDUser",
            "type": "number"
        },
        {
            "name": "AuthorizedIDUser",
            "baseName": "AuthorizedIDUser",
            "type": "number"
        },
        {
            "name": "CMSIDUser",
            "baseName": "CMSIDUser",
            "type": "number"
        },
        {
            "name": "Datum",
            "baseName": "Datum",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Sample.attributeTypeMap;
    }
}

/**
* 
*/
export class SampleLabJoin {
    /**
    * 
    */
    'IDSampleLabJoin': number;
    /**
    * 
    */
    'GUIDSampleLabJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDLab': number;
    /**
    * 
    */
    'IDSample': number;
    /**
    * 
    */
    'Received': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDSampleLabJoin",
            "baseName": "IDSampleLabJoin",
            "type": "number"
        },
        {
            "name": "GUIDSampleLabJoin",
            "baseName": "GUIDSampleLabJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        },
        {
            "name": "IDSample",
            "baseName": "IDSample",
            "type": "number"
        },
        {
            "name": "Received",
            "baseName": "Received",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SampleLabJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class SampleLineItemJoin {
    /**
    * 
    */
    'IDSampleLineItemJoin': number;
    /**
    * 
    */
    'GUIDSampleLineItemJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'IDLineItem': number;
    /**
    * 
    */
    'IDSample': number;
    /**
    * 
    */
    'RepresentedQuantity': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDSampleLineItemJoin",
            "baseName": "IDSampleLineItemJoin",
            "type": "number"
        },
        {
            "name": "GUIDSampleLineItemJoin",
            "baseName": "GUIDSampleLineItemJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "IDLineItem",
            "baseName": "IDLineItem",
            "type": "number"
        },
        {
            "name": "IDSample",
            "baseName": "IDSample",
            "type": "number"
        },
        {
            "name": "RepresentedQuantity",
            "baseName": "RepresentedQuantity",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SampleLineItemJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class SampleLog {
    /**
    * 
    */
    'IDSampleLog': number;
    /**
    * 
    */
    'GUIDSampleLog': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDSample': number;
    /**
    * 
    */
    'CaptureLatitude': string;
    /**
    * 
    */
    'CaptureLongitude': string;
    /**
    * 
    */
    'UserLatitude': string;
    /**
    * 
    */
    'UserLongitude': string;
    /**
    * 
    */
    'AlignmentStation': string;
    /**
    * 
    */
    'AlignmentOffset': string;
    /**
    * 
    */
    'Notes': string;
    /**
    * 
    */
    'CaptureDate': Date;
    /**
    * 
    */
    'IDLab': number;
    /**
    * 
    */
    'Received': number;
    /**
    * 
    */
    'ExternalSyncGUID': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDSampleLog",
            "baseName": "IDSampleLog",
            "type": "number"
        },
        {
            "name": "GUIDSampleLog",
            "baseName": "GUIDSampleLog",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDSample",
            "baseName": "IDSample",
            "type": "number"
        },
        {
            "name": "CaptureLatitude",
            "baseName": "CaptureLatitude",
            "type": "string"
        },
        {
            "name": "CaptureLongitude",
            "baseName": "CaptureLongitude",
            "type": "string"
        },
        {
            "name": "UserLatitude",
            "baseName": "UserLatitude",
            "type": "string"
        },
        {
            "name": "UserLongitude",
            "baseName": "UserLongitude",
            "type": "string"
        },
        {
            "name": "AlignmentStation",
            "baseName": "AlignmentStation",
            "type": "string"
        },
        {
            "name": "AlignmentOffset",
            "baseName": "AlignmentOffset",
            "type": "string"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "CaptureDate",
            "baseName": "CaptureDate",
            "type": "Date"
        },
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        },
        {
            "name": "Received",
            "baseName": "Received",
            "type": "number"
        },
        {
            "name": "ExternalSyncGUID",
            "baseName": "ExternalSyncGUID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SampleLog.attributeTypeMap;
    }
}

/**
* 
*/
export class SendToEmailRequest {
    /**
    * 
    */
    'IDDocument': number;
    /**
    * 
    */
    'EmailAddressList': Array<string>;
    /**
    * 
    */
    'Subject': string;
    /**
    * 
    */
    'Message': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDDocument",
            "baseName": "IDDocument",
            "type": "number"
        },
        {
            "name": "EmailAddressList",
            "baseName": "EmailAddressList",
            "type": "Array<string>"
        },
        {
            "name": "Subject",
            "baseName": "Subject",
            "type": "string"
        },
        {
            "name": "Message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SendToEmailRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class Test {
    /**
    * 
    */
    'IDTest': number;
    /**
    * 
    */
    'GUIDTest': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Notes': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTest",
            "baseName": "IDTest",
            "type": "number"
        },
        {
            "name": "GUIDTest",
            "baseName": "GUIDTest",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Test.attributeTypeMap;
    }
}

/**
* 
*/
export class TestData {
    /**
    * 
    */
    'IDTestData': number;
    /**
    * 
    */
    'GUIDTestData': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Hash': string;
    /**
    * 
    */
    'DisplayName': string;
    /**
    * 
    */
    'Type': string;
    /**
    * 
    */
    'Required': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestData",
            "baseName": "IDTestData",
            "type": "number"
        },
        {
            "name": "GUIDTestData",
            "baseName": "GUIDTestData",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Hash",
            "baseName": "Hash",
            "type": "string"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Type",
            "baseName": "Type",
            "type": "string"
        },
        {
            "name": "Required",
            "baseName": "Required",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TestData.attributeTypeMap;
    }
}

/**
* 
*/
export class TestInstance {
    /**
    * 
    */
    'IDTestInstance': number;
    /**
    * 
    */
    'GUIDTestInstance': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDTestPlan': number;
    /**
    * 
    */
    'IDTest': number;
    /**
    * 
    */
    'IDLab': number;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'IDBidItem': number;
    /**
    * 
    */
    'IDLineItem': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Notes': string;
    /**
    * 
    */
    'StartDate': Date;
    /**
    * 
    */
    'EstimatedCompletionDate': Date;
    /**
    * 
    */
    'ActualCompletionDate': Date;
    /**
    * 
    */
    'ExternalSyncGUID': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestInstance",
            "baseName": "IDTestInstance",
            "type": "number"
        },
        {
            "name": "GUIDTestInstance",
            "baseName": "GUIDTestInstance",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDTestPlan",
            "baseName": "IDTestPlan",
            "type": "number"
        },
        {
            "name": "IDTest",
            "baseName": "IDTest",
            "type": "number"
        },
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "IDBidItem",
            "baseName": "IDBidItem",
            "type": "number"
        },
        {
            "name": "IDLineItem",
            "baseName": "IDLineItem",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "StartDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "EstimatedCompletionDate",
            "baseName": "EstimatedCompletionDate",
            "type": "Date"
        },
        {
            "name": "ActualCompletionDate",
            "baseName": "ActualCompletionDate",
            "type": "Date"
        },
        {
            "name": "ExternalSyncGUID",
            "baseName": "ExternalSyncGUID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TestInstance.attributeTypeMap;
    }
}

/**
* 
*/
export class TestInstanceData {
    /**
    * 
    */
    'IDTestInstanceData': number;
    /**
    * 
    */
    'GUIDTestInstanceData': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Hash': string;
    /**
    * 
    */
    'Value': string;
    /**
    * 
    */
    'Comments': string;
    /**
    * 
    */
    'Valid': number;
    /**
    * 
    */
    'ExternalSyncGUID': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestInstanceData",
            "baseName": "IDTestInstanceData",
            "type": "number"
        },
        {
            "name": "GUIDTestInstanceData",
            "baseName": "GUIDTestInstanceData",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Hash",
            "baseName": "Hash",
            "type": "string"
        },
        {
            "name": "Value",
            "baseName": "Value",
            "type": "string"
        },
        {
            "name": "Comments",
            "baseName": "Comments",
            "type": "string"
        },
        {
            "name": "Valid",
            "baseName": "Valid",
            "type": "number"
        },
        {
            "name": "ExternalSyncGUID",
            "baseName": "ExternalSyncGUID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TestInstanceData.attributeTypeMap;
    }
}

/**
* 
*/
export class TestInstanceDataArchive {
    /**
    * 
    */
    'IDTestInstanceDataArchive': number;
    /**
    * 
    */
    'GUIDTestInstanceDataArchive': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDTestInstanceData': number;
    /**
    * 
    */
    'TestInstanceData': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestInstanceDataArchive",
            "baseName": "IDTestInstanceDataArchive",
            "type": "number"
        },
        {
            "name": "GUIDTestInstanceDataArchive",
            "baseName": "GUIDTestInstanceDataArchive",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDTestInstanceData",
            "baseName": "IDTestInstanceData",
            "type": "number"
        },
        {
            "name": "TestInstanceData",
            "baseName": "TestInstanceData",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TestInstanceDataArchive.attributeTypeMap;
    }
}

/**
* 
*/
export class TestInstanceLabJoin {
    /**
    * 
    */
    'IDTestInstanceLabJoin': number;
    /**
    * 
    */
    'GUIDTestInstanceLabJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDTestInstance': number;
    /**
    * 
    */
    'IDLab': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestInstanceLabJoin",
            "baseName": "IDTestInstanceLabJoin",
            "type": "number"
        },
        {
            "name": "GUIDTestInstanceLabJoin",
            "baseName": "GUIDTestInstanceLabJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDTestInstance",
            "baseName": "IDTestInstance",
            "type": "number"
        },
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TestInstanceLabJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class TestInstanceSampleJoin {
    /**
    * 
    */
    'IDTestInstanceSampleJoin': number;
    /**
    * 
    */
    'GUIDTestInstanceSampleJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDTestInstance': number;
    /**
    * 
    */
    'IDSample': number;
    /**
    * 
    */
    'IDCustomer': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestInstanceSampleJoin",
            "baseName": "IDTestInstanceSampleJoin",
            "type": "number"
        },
        {
            "name": "GUIDTestInstanceSampleJoin",
            "baseName": "GUIDTestInstanceSampleJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDTestInstance",
            "baseName": "IDTestInstance",
            "type": "number"
        },
        {
            "name": "IDSample",
            "baseName": "IDSample",
            "type": "number"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TestInstanceSampleJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class TestLabJoin {
    /**
    * 
    */
    'IDTestLabJoin': number;
    /**
    * 
    */
    'GUIDTestLabJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDLab': number;
    /**
    * 
    */
    'IDLabParent': number;
    /**
    * 
    */
    'IDTest': number;
    /**
    * 
    */
    'DateEnd': Date;
    /**
    * 
    */
    'QualificationType': string;
    /**
    * 
    */
    'QualificationMethod': string;
    /**
    * 
    */
    'QualificationAuthorization': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestLabJoin",
            "baseName": "IDTestLabJoin",
            "type": "number"
        },
        {
            "name": "GUIDTestLabJoin",
            "baseName": "GUIDTestLabJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        },
        {
            "name": "IDLabParent",
            "baseName": "IDLabParent",
            "type": "number"
        },
        {
            "name": "IDTest",
            "baseName": "IDTest",
            "type": "number"
        },
        {
            "name": "DateEnd",
            "baseName": "DateEnd",
            "type": "Date"
        },
        {
            "name": "QualificationType",
            "baseName": "QualificationType",
            "type": "string"
        },
        {
            "name": "QualificationMethod",
            "baseName": "QualificationMethod",
            "type": "string"
        },
        {
            "name": "QualificationAuthorization",
            "baseName": "QualificationAuthorization",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TestLabJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class TestPlan {
    /**
    * 
    */
    'IDTestPlan': number;
    /**
    * 
    */
    'GUIDTestPlan': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'Description': string;
    /**
    * 
    */
    'DateStart': Date;
    /**
    * 
    */
    'DateEnd': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestPlan",
            "baseName": "IDTestPlan",
            "type": "number"
        },
        {
            "name": "GUIDTestPlan",
            "baseName": "GUIDTestPlan",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "DateStart",
            "baseName": "DateStart",
            "type": "Date"
        },
        {
            "name": "DateEnd",
            "baseName": "DateEnd",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return TestPlan.attributeTypeMap;
    }
}

/**
* 
*/
export class TestRecordOfMaterialEntryJoin {
    /**
    * 
    */
    'IDTestRecordOfMaterialEntryJoin': number;
    /**
    * 
    */
    'GUIDTestRecordOfMaterialEntryJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDTestPlan': number;
    /**
    * 
    */
    'IDTest': number;
    /**
    * 
    */
    'IDLab': number;
    /**
    * 
    */
    'IDProject': number;
    /**
    * 
    */
    'IDBidItem': number;
    /**
    * 
    */
    'IDLineItem': number;
    /**
    * 
    */
    'TestCount': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Notes': string;
    /**
    * 
    */
    'IDRecordOfMaterialEntry': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestRecordOfMaterialEntryJoin",
            "baseName": "IDTestRecordOfMaterialEntryJoin",
            "type": "number"
        },
        {
            "name": "GUIDTestRecordOfMaterialEntryJoin",
            "baseName": "GUIDTestRecordOfMaterialEntryJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDTestPlan",
            "baseName": "IDTestPlan",
            "type": "number"
        },
        {
            "name": "IDTest",
            "baseName": "IDTest",
            "type": "number"
        },
        {
            "name": "IDLab",
            "baseName": "IDLab",
            "type": "number"
        },
        {
            "name": "IDProject",
            "baseName": "IDProject",
            "type": "number"
        },
        {
            "name": "IDBidItem",
            "baseName": "IDBidItem",
            "type": "number"
        },
        {
            "name": "IDLineItem",
            "baseName": "IDLineItem",
            "type": "number"
        },
        {
            "name": "TestCount",
            "baseName": "TestCount",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "IDRecordOfMaterialEntry",
            "baseName": "IDRecordOfMaterialEntry",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TestRecordOfMaterialEntryJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class TestSpecification {
    /**
    * 
    */
    'IDTestSpecification': number;
    /**
    * 
    */
    'GUIDTestSpecification': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'IDTestSpecificationSet': number;
    /**
    * 
    */
    'Description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestSpecification",
            "baseName": "IDTestSpecification",
            "type": "number"
        },
        {
            "name": "GUIDTestSpecification",
            "baseName": "GUIDTestSpecification",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "IDTestSpecificationSet",
            "baseName": "IDTestSpecificationSet",
            "type": "number"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TestSpecification.attributeTypeMap;
    }
}

/**
* 
*/
export class TestSpecificationMaterialTestJoin {
    /**
    * 
    */
    'IDTestSpecificationMaterialTestJoin': number;
    /**
    * 
    */
    'GUIDTestSpecificationMaterialTestJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDTestSpecification': number;
    /**
    * 
    */
    'IDMaterial': number;
    /**
    * 
    */
    'IDTest': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestSpecificationMaterialTestJoin",
            "baseName": "IDTestSpecificationMaterialTestJoin",
            "type": "number"
        },
        {
            "name": "GUIDTestSpecificationMaterialTestJoin",
            "baseName": "GUIDTestSpecificationMaterialTestJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDTestSpecification",
            "baseName": "IDTestSpecification",
            "type": "number"
        },
        {
            "name": "IDMaterial",
            "baseName": "IDMaterial",
            "type": "number"
        },
        {
            "name": "IDTest",
            "baseName": "IDTest",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TestSpecificationMaterialTestJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class TestSpecificationRequirement {
    /**
    * 
    */
    'IDTestSpecificationRequirement': number;
    /**
    * 
    */
    'GUIDTestSpecificationRequirement': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDTestSpecification': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Ordinal': string;
    /**
    * 
    */
    'OperationType': string;
    /**
    * 
    */
    'ValueMinimum': string;
    /**
    * 
    */
    'ValueMaximum': string;
    /**
    * 
    */
    'ComputationTemplate': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestSpecificationRequirement",
            "baseName": "IDTestSpecificationRequirement",
            "type": "number"
        },
        {
            "name": "GUIDTestSpecificationRequirement",
            "baseName": "GUIDTestSpecificationRequirement",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDTestSpecification",
            "baseName": "IDTestSpecification",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Ordinal",
            "baseName": "Ordinal",
            "type": "string"
        },
        {
            "name": "OperationType",
            "baseName": "OperationType",
            "type": "string"
        },
        {
            "name": "ValueMinimum",
            "baseName": "ValueMinimum",
            "type": "string"
        },
        {
            "name": "ValueMaximum",
            "baseName": "ValueMaximum",
            "type": "string"
        },
        {
            "name": "ComputationTemplate",
            "baseName": "ComputationTemplate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TestSpecificationRequirement.attributeTypeMap;
    }
}

/**
* 
*/
export class TestSpecificationSet {
    /**
    * 
    */
    'IDTestSpecificationSet': number;
    /**
    * 
    */
    'GUIDTestSpecificationSet': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Year': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestSpecificationSet",
            "baseName": "IDTestSpecificationSet",
            "type": "number"
        },
        {
            "name": "GUIDTestSpecificationSet",
            "baseName": "GUIDTestSpecificationSet",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Year",
            "baseName": "Year",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TestSpecificationSet.attributeTypeMap;
    }
}

/**
* 
*/
export class TestSpecificationSetTestJoin {
    /**
    * 
    */
    'IDTestSpecificationSetTestJoin': number;
    /**
    * 
    */
    'GUIDTestSpecificationSetTestJoin': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'IDTestSpecificationSet': number;
    /**
    * 
    */
    'IDTest': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestSpecificationSetTestJoin",
            "baseName": "IDTestSpecificationSetTestJoin",
            "type": "number"
        },
        {
            "name": "GUIDTestSpecificationSetTestJoin",
            "baseName": "GUIDTestSpecificationSetTestJoin",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "IDTestSpecificationSet",
            "baseName": "IDTestSpecificationSet",
            "type": "number"
        },
        {
            "name": "IDTest",
            "baseName": "IDTest",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TestSpecificationSetTestJoin.attributeTypeMap;
    }
}

/**
* 
*/
export class TestStep {
    /**
    * 
    */
    'IDTestStep': number;
    /**
    * 
    */
    'GUIDTestStep': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'Name': string;
    /**
    * 
    */
    'Notes': string;
    /**
    * 
    */
    'Computed': number;
    /**
    * 
    */
    'ComputationTemplate': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "IDTestStep",
            "baseName": "IDTestStep",
            "type": "number"
        },
        {
            "name": "GUIDTestStep",
            "baseName": "GUIDTestStep",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Notes",
            "baseName": "Notes",
            "type": "string"
        },
        {
            "name": "Computed",
            "baseName": "Computed",
            "type": "number"
        },
        {
            "name": "ComputationTemplate",
            "baseName": "ComputationTemplate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TestStep.attributeTypeMap;
    }
}

/**
* 
*/
export class UserModel {
    /**
    * 
    */
    'Settings': any;
    /**
    * 
    */
    'IDUser': number;
    /**
    * 
    */
    'GUIDUser': string;
    /**
    * 
    */
    'CreateDate': Date;
    /**
    * 
    */
    'CreatingIDUser': number;
    /**
    * 
    */
    'UpdateDate': Date;
    /**
    * 
    */
    'UpdatingIDUser': number;
    /**
    * 
    */
    'Deleted': number;
    /**
    * 
    */
    'DeleteDate': Date;
    /**
    * 
    */
    'DeletingIDUser': number;
    /**
    * 
    */
    'NameFirst': string;
    /**
    * 
    */
    'NameLast': string;
    /**
    * 
    */
    'Email': string;
    /**
    * 
    */
    'LoginID': string;
    /**
    * 
    */
    'IDRole': number;
    /**
    * 
    */
    'Title': string;
    /**
    * 
    */
    'Classification': string;
    /**
    * 
    */
    'IDProjectOffice': number;
    /**
    * 
    */
    'IDCustomer': number;
    /**
    * 
    */
    'EmailPending': number;
    /**
    * 
    */
    'Phone': string;
    /**
    * 
    */
    'UIHash': string;
    /**
    * 
    */
    'Timezone': string;
    /**
    * 
    */
    'Shift': string;
    /**
    * 
    */
    'ExternalSyncDate': Date;
    /**
    * 
    */
    'LastLoginTime': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "any"
        },
        {
            "name": "IDUser",
            "baseName": "IDUser",
            "type": "number"
        },
        {
            "name": "GUIDUser",
            "baseName": "GUIDUser",
            "type": "string"
        },
        {
            "name": "CreateDate",
            "baseName": "CreateDate",
            "type": "Date"
        },
        {
            "name": "CreatingIDUser",
            "baseName": "CreatingIDUser",
            "type": "number"
        },
        {
            "name": "UpdateDate",
            "baseName": "UpdateDate",
            "type": "Date"
        },
        {
            "name": "UpdatingIDUser",
            "baseName": "UpdatingIDUser",
            "type": "number"
        },
        {
            "name": "Deleted",
            "baseName": "Deleted",
            "type": "number"
        },
        {
            "name": "DeleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "DeletingIDUser",
            "baseName": "DeletingIDUser",
            "type": "number"
        },
        {
            "name": "NameFirst",
            "baseName": "NameFirst",
            "type": "string"
        },
        {
            "name": "NameLast",
            "baseName": "NameLast",
            "type": "string"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "LoginID",
            "baseName": "LoginID",
            "type": "string"
        },
        {
            "name": "IDRole",
            "baseName": "IDRole",
            "type": "number"
        },
        {
            "name": "Title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "Classification",
            "baseName": "Classification",
            "type": "string"
        },
        {
            "name": "IDProjectOffice",
            "baseName": "IDProjectOffice",
            "type": "number"
        },
        {
            "name": "IDCustomer",
            "baseName": "IDCustomer",
            "type": "number"
        },
        {
            "name": "EmailPending",
            "baseName": "EmailPending",
            "type": "number"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "UIHash",
            "baseName": "UIHash",
            "type": "string"
        },
        {
            "name": "Timezone",
            "baseName": "Timezone",
            "type": "string"
        },
        {
            "name": "Shift",
            "baseName": "Shift",
            "type": "string"
        },
        {
            "name": "ExternalSyncDate",
            "baseName": "ExternalSyncDate",
            "type": "Date"
        },
        {
            "name": "LastLoginTime",
            "baseName": "LastLoginTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return UserModel.attributeTypeMap;
    }
}

/**
* 
*/
export class UserSignupRequest {
    /**
    * 
    */
    'NameFirst': string;
    /**
    * 
    */
    'NameLast': string;
    /**
    * 
    */
    'Email': string;
    /**
    * 
    */
    'Password': string;
    /**
    * 
    */
    'Phone': string;
    /**
    * 
    */
    'CompanyName': string;
    'CompanyDetails': UserSignupRequestCompanyDetails;
    /**
    * 
    */
    'Position': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "NameFirst",
            "baseName": "NameFirst",
            "type": "string"
        },
        {
            "name": "NameLast",
            "baseName": "NameLast",
            "type": "string"
        },
        {
            "name": "Email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "Password",
            "baseName": "Password",
            "type": "string"
        },
        {
            "name": "Phone",
            "baseName": "Phone",
            "type": "string"
        },
        {
            "name": "CompanyName",
            "baseName": "CompanyName",
            "type": "string"
        },
        {
            "name": "CompanyDetails",
            "baseName": "CompanyDetails",
            "type": "UserSignupRequestCompanyDetails"
        },
        {
            "name": "Position",
            "baseName": "Position",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserSignupRequest.attributeTypeMap;
    }
}

/**
* 
*/
export class UserSignupRequestCompanyDetails {
    /**
    * 
    */
    'State'?: string;
    /**
    * 
    */
    'Size'?: number;
    /**
    * 
    */
    'EstimatedAnnualRevenue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "State",
            "baseName": "State",
            "type": "string"
        },
        {
            "name": "Size",
            "baseName": "Size",
            "type": "number"
        },
        {
            "name": "EstimatedAnnualRevenue",
            "baseName": "EstimatedAnnualRevenue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserSignupRequestCompanyDetails.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "Artifact": Artifact,
    "ArtifactModel": ArtifactModel,
    "BidItem": BidItem,
    "ChangePasswordRequest": ChangePasswordRequest,
    "CommentModel": CommentModel,
    "Contract": Contract,
    "Customer": Customer,
    "DocumentModel": DocumentModel,
    "DocumentStateChangeRequest": DocumentStateChangeRequest,
    "ElectronicSignature": ElectronicSignature,
    "ElectronicSignatureModel": ElectronicSignatureModel,
    "Equipment": Equipment,
    "ISession": ISession,
    "InlineResponse200": InlineResponse200,
    "InlineResponse2001": InlineResponse2001,
    "Lab": Lab,
    "LabMaterialAssignment": LabMaterialAssignment,
    "LabTestApproval": LabTestApproval,
    "LabTestDefault": LabTestDefault,
    "LineItem": LineItem,
    "LoginRequest": LoginRequest,
    "MappedArrayArtifact": MappedArrayArtifact,
    "Material": Material,
    "MaterialLineItemJoin": MaterialLineItemJoin,
    "MaterialPayItemJoin": MaterialPayItemJoin,
    "MaterialRecordOfMaterialEntryJoin": MaterialRecordOfMaterialEntryJoin,
    "MixSpecification": MixSpecification,
    "MixSpecificationMaterialJoin": MixSpecificationMaterialJoin,
    "ModuleModel": ModuleModel,
    "Notification": Notification,
    "ObservationArchive": ObservationArchive,
    "ObservationCloneRequest": ObservationCloneRequest,
    "ObservationFilterRequest": ObservationFilterRequest,
    "ObservationFilterRequestDesignatedTime": ObservationFilterRequestDesignatedTime,
    "ObservationFilterRequestPriority": ObservationFilterRequestPriority,
    "ObservationModel": ObservationModel,
    "ObservationModelLabels": ObservationModelLabels,
    "Organization": Organization,
    "OrganizationMaterialJoin": OrganizationMaterialJoin,
    "PayItemModel": PayItemModel,
    "Product": Product,
    "ProductionPlant": ProductionPlant,
    "ProductionPlantMaterialApproval": ProductionPlantMaterialApproval,
    "ProjectModel": ProjectModel,
    "QueryRequest": QueryRequest,
    "RecordOfMaterial": RecordOfMaterial,
    "RecordOfMaterialEntry": RecordOfMaterialEntry,
    "RecordOfMaterialEntryArchive": RecordOfMaterialEntryArchive,
    "ReportModel": ReportModel,
    "ReportNamedInstanceModel": ReportNamedInstanceModel,
    "ReportRenderResult": ReportRenderResult,
    "Sample": Sample,
    "SampleLabJoin": SampleLabJoin,
    "SampleLineItemJoin": SampleLineItemJoin,
    "SampleLog": SampleLog,
    "SendToEmailRequest": SendToEmailRequest,
    "Test": Test,
    "TestData": TestData,
    "TestInstance": TestInstance,
    "TestInstanceData": TestInstanceData,
    "TestInstanceDataArchive": TestInstanceDataArchive,
    "TestInstanceLabJoin": TestInstanceLabJoin,
    "TestInstanceSampleJoin": TestInstanceSampleJoin,
    "TestLabJoin": TestLabJoin,
    "TestPlan": TestPlan,
    "TestRecordOfMaterialEntryJoin": TestRecordOfMaterialEntryJoin,
    "TestSpecification": TestSpecification,
    "TestSpecificationMaterialTestJoin": TestSpecificationMaterialTestJoin,
    "TestSpecificationRequirement": TestSpecificationRequirement,
    "TestSpecificationSet": TestSpecificationSet,
    "TestSpecificationSetTestJoin": TestSpecificationSetTestJoin,
    "TestStep": TestStep,
    "UserModel": UserModel,
    "UserSignupRequest": UserSignupRequest,
    "UserSignupRequestCompanyDetails": UserSignupRequestCompanyDetails,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
    executeWithAuth<T>(requestOptions: localVarRequest.Options, requestDelegate: ()=>Promise<T>): Promise<T>;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }

    executeWithAuth<T>(requestOptions: localVarRequest.Options, requestDelegate: ()=>Promise<T>): Promise<T>
    {
        return requestDelegate();
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
    executeWithAuth<T>(requestOptions: localVarRequest.Options, requestDelegate: ()=>Promise<T>): Promise<T>
    {
        return requestDelegate();
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
    executeWithAuth<T>(requestOptions: localVarRequest.Options, requestDelegate: ()=>Promise<T>): Promise<T>
    {
        return requestDelegate();
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
    executeWithAuth<T>(requestOptions: localVarRequest.Options, requestDelegate: ()=>Promise<T>): Promise<T>
    {
        return requestDelegate();
    }
}

export enum ArtifactApiApiKeys {
}

export class ArtifactApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ArtifactApiApiKeys, value: string) {
        (this.authentications as any)[ArtifactApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Artifact/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Switch Artifact records Sync flag
     * @param IDArtifact ID of record
     */
    public clearArtifactSyncFlag (IDArtifact: number) : Promise<any> {
        const localVarPath = this.basePath + '/Artifact/{IDArtifact}/ClearSyncFlag'
            .replace('{' + 'IDArtifact' + '}', encodeURIComponent(String(IDArtifact)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDArtifact' is not null or undefined
        if (IDArtifact === null || IDArtifact === undefined) {
            throw new Error('Required parameter IDArtifact was null or undefined when calling clearArtifactSyncFlag.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in clearArtifactSyncFlag!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Copy Artifact media from ID to target ID
     * @param IDTargetArtifact ID of record
     * @param IDObservationArtifact ID of record
     * @param ArtifactVersion 
     * @param TargetArtifactVersion 
     */
    public copyArtifact (IDTargetArtifact: number, IDObservationArtifact: number, ArtifactVersion: number, TargetArtifactVersion: number) : Promise<any> {
        const localVarPath = this.basePath + '/Artifact/Media/{IDObservationArtifact}/{ArtifactVersion}/CopyTo/{IDTargetArtifact}/{TargetArtifactVersion}'
            .replace('{' + 'IDTargetArtifact' + '}', encodeURIComponent(String(IDTargetArtifact)))
            .replace('{' + 'IDObservationArtifact' + '}', encodeURIComponent(String(IDObservationArtifact)))
            .replace('{' + 'ArtifactVersion' + '}', encodeURIComponent(String(ArtifactVersion)))
            .replace('{' + 'TargetArtifactVersion' + '}', encodeURIComponent(String(TargetArtifactVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDTargetArtifact' is not null or undefined
        if (IDTargetArtifact === null || IDTargetArtifact === undefined) {
            throw new Error('Required parameter IDTargetArtifact was null or undefined when calling copyArtifact.');
        }

        // verify required parameter 'IDObservationArtifact' is not null or undefined
        if (IDObservationArtifact === null || IDObservationArtifact === undefined) {
            throw new Error('Required parameter IDObservationArtifact was null or undefined when calling copyArtifact.');
        }

        // verify required parameter 'ArtifactVersion' is not null or undefined
        if (ArtifactVersion === null || ArtifactVersion === undefined) {
            throw new Error('Required parameter ArtifactVersion was null or undefined when calling copyArtifact.');
        }

        // verify required parameter 'TargetArtifactVersion' is not null or undefined
        if (TargetArtifactVersion === null || TargetArtifactVersion === undefined) {
            throw new Error('Required parameter TargetArtifactVersion was null or undefined when calling copyArtifact.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in copyArtifact!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Artifacts/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Artifacts/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: ArtifactModel) : Promise<ArtifactModel> {
        const localVarPath = this.basePath + '/Artifact';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ArtifactModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ArtifactModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Download Artifact media file from Headlight
     * @param IDObservationArtifact ID of record
     * @param Size 
     * @param ArtifactVersion 
     */
    public downloadArtifact (IDObservationArtifact: number, Size: string, ArtifactVersion: string) : Promise<Buffer> {
        const localVarPath = this.basePath + '/Artifact/Media/{IDObservationArtifact}/{ArtifactVersion}/{Size}'
            .replace('{' + 'IDObservationArtifact' + '}', encodeURIComponent(String(IDObservationArtifact)))
            .replace('{' + 'Size' + '}', encodeURIComponent(String(Size)))
            .replace('{' + 'ArtifactVersion' + '}', encodeURIComponent(String(ArtifactVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservationArtifact' is not null or undefined
        if (IDObservationArtifact === null || IDObservationArtifact === undefined) {
            throw new Error('Required parameter IDObservationArtifact was null or undefined when calling downloadArtifact.');
        }

        // verify required parameter 'Size' is not null or undefined
        if (Size === null || Size === undefined) {
            throw new Error('Required parameter Size was null or undefined when calling downloadArtifact.');
        }

        // verify required parameter 'ArtifactVersion' is not null or undefined
        if (ArtifactVersion === null || ArtifactVersion === undefined) {
            throw new Error('Required parameter ArtifactVersion was null or undefined when calling downloadArtifact.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Buffer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Buffer");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in downloadArtifact!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Get Artifact records for media types that don't have the Sync flag set
     */
    public getArtifactSyncList () : Promise<Array<Artifact>> {
        const localVarPath = this.basePath + '/Artifact/Media/GetSyncList';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Artifact>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Artifact>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getArtifactSyncList!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Artifact/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<ArtifactModel>> {
        const localVarPath = this.basePath + '/Artifact/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ArtifactModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ArtifactModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<ArtifactModel> {
        const localVarPath = this.basePath + '/Artifact/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ArtifactModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<ArtifactModel>> {
        const localVarPath = this.basePath + '/Artifacts/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ArtifactModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ArtifactModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<ArtifactModel>> {
        const localVarPath = this.basePath + '/Artifacts/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ArtifactModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ArtifactModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: ArtifactModel) : Promise<ArtifactModel> {
        const localVarPath = this.basePath + '/Artifact';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ArtifactModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ArtifactModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ArtifactModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Upload Artifact media file to Headlight
     * @param IDObservationArtifact ID of record
     * @param file 
     * @param ArtifactVersion 
     */
    public uploadArtifact (IDObservationArtifact: number, file: Buffer, ArtifactVersion: number) : Promise<any> {
        const localVarPath = this.basePath + '/Artifact/Media/{IDObservationArtifact}/{ArtifactVersion}'
            .replace('{' + 'IDObservationArtifact' + '}', encodeURIComponent(String(IDObservationArtifact)))
            .replace('{' + 'ArtifactVersion' + '}', encodeURIComponent(String(ArtifactVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservationArtifact' is not null or undefined
        if (IDObservationArtifact === null || IDObservationArtifact === undefined) {
            throw new Error('Required parameter IDObservationArtifact was null or undefined when calling uploadArtifact.');
        }

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling uploadArtifact.');
        }

        // verify required parameter 'ArtifactVersion' is not null or undefined
        if (ArtifactVersion === null || ArtifactVersion === undefined) {
            throw new Error('Required parameter ArtifactVersion was null or undefined when calling uploadArtifact.');
        }


        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in uploadArtifact!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum AuthenticateApiApiKeys {
}

export class AuthenticateApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthenticateApiApiKeys, value: string) {
        (this.authentications as any)[AuthenticateApiApiKeys[key]].apiKey = value;
    }
    /**
     * Forward authentication request to authentication microservice.
     * @param body 
     */
    public authenticate (body: LoginRequest) : Promise<ISession> {
        const localVarPath = this.basePath + '/Authenticate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling authenticate.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "LoginRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ISession>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ISession");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in authenticate!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Get current session state from server
     */
    public checkSession () : Promise<ISession> {
        const localVarPath = this.basePath + '/CheckSession';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ISession>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ISession");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in checkSession!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Check out temporary authentication token for user in session.
     */
    public checkoutSessionToken () : Promise<any> {
        const localVarPath = this.basePath + '/CheckoutSessionToken';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in checkoutSessionToken!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Logout user (remove session from server)
     */
    public deAuthenticate () : Promise<InlineResponse2001> {
        const localVarPath = this.basePath + '/Deauthenticate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse2001>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse2001");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in deAuthenticate!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Impersonate another user, according to access rights.
     * @param IDUser 
     */
    public impersonateUser (IDUser: number) : Promise<any> {
        const localVarPath = this.basePath + '/Authenticate/Impersonate/{IDUser}'
            .replace('{' + 'IDUser' + '}', encodeURIComponent(String(IDUser)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDUser' is not null or undefined
        if (IDUser === null || IDUser === undefined) {
            throw new Error('Required parameter IDUser was null or undefined when calling impersonateUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in impersonateUser!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum BatchExportApiApiKeys {
}

export class BatchExportApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BatchExportApiApiKeys, value: string) {
        (this.authentications as any)[BatchExportApiApiKeys[key]].apiKey = value;
    }
    /**
     * Begin Batch Export Job
     */
    public batchExport () : Promise<any> {
        const localVarPath = this.basePath + '/BatchExport';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in batchExport!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * List export files that are ready for download
     * @param ExportType 
     */
    public batchExportListFiles (ExportType: string) : Promise<any> {
        const localVarPath = this.basePath + '/BatchExport/Files/{ExportType}'
            .replace('{' + 'ExportType' + '}', encodeURIComponent(String(ExportType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'ExportType' is not null or undefined
        if (ExportType === null || ExportType === undefined) {
            throw new Error('Required parameter ExportType was null or undefined when calling batchExportListFiles.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in batchExportListFiles!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum BidItemApiApiKeys {
}

export class BidItemApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BidItemApiApiKeys, value: string) {
        (this.authentications as any)[BidItemApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/BidItem/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/BidItems/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/BidItems/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: BidItem) : Promise<BidItem> {
        const localVarPath = this.basePath + '/BidItem';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BidItem")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<BidItem>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "BidItem");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/BidItem/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<BidItem>> {
        const localVarPath = this.basePath + '/BidItem/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<BidItem>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<BidItem>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<BidItem> {
        const localVarPath = this.basePath + '/BidItem/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<BidItem>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "BidItem");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<BidItem>> {
        const localVarPath = this.basePath + '/BidItems/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<BidItem>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<BidItem>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<BidItem>> {
        const localVarPath = this.basePath + '/BidItems/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<BidItem>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<BidItem>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: BidItem) : Promise<BidItem> {
        const localVarPath = this.basePath + '/BidItem';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BidItem")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<BidItem>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "BidItem");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum CommentApiApiKeys {
}

export class CommentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CommentApiApiKeys, value: string) {
        (this.authentications as any)[CommentApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Comment/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Comments/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Comments/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: CommentModel) : Promise<CommentModel> {
        const localVarPath = this.basePath + '/Comment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CommentModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<CommentModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CommentModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Comment/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<CommentModel>> {
        const localVarPath = this.basePath + '/Comment/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<CommentModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<CommentModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<CommentModel> {
        const localVarPath = this.basePath + '/Comment/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<CommentModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CommentModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<CommentModel>> {
        const localVarPath = this.basePath + '/Comments/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<CommentModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<CommentModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<CommentModel>> {
        const localVarPath = this.basePath + '/Comments/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<CommentModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<CommentModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: CommentModel) : Promise<CommentModel> {
        const localVarPath = this.basePath + '/Comment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CommentModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<CommentModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CommentModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ContractApiApiKeys {
}

export class ContractApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContractApiApiKeys, value: string) {
        (this.authentications as any)[ContractApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Contract/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Contracts/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Contracts/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: Contract) : Promise<Contract> {
        const localVarPath = this.basePath + '/Contract';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Contract")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Contract>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Contract");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Contract/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<Contract>> {
        const localVarPath = this.basePath + '/Contract/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Contract>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Contract>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<Contract> {
        const localVarPath = this.basePath + '/Contract/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Contract>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Contract");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<Contract>> {
        const localVarPath = this.basePath + '/Contracts/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Contract>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Contract>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<Contract>> {
        const localVarPath = this.basePath + '/Contracts/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Contract>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Contract>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: Contract) : Promise<Contract> {
        const localVarPath = this.basePath + '/Contract';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Contract")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Contract>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Contract");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum CustomerApiApiKeys {
}

export class CustomerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerApiApiKeys, value: string) {
        (this.authentications as any)[CustomerApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Customer/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Customers/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Customers/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: Customer) : Promise<Customer> {
        const localVarPath = this.basePath + '/Customer';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Customer")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Customer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Customer");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Customer/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<Customer>> {
        const localVarPath = this.basePath + '/Customer/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Customer>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Customer>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<Customer> {
        const localVarPath = this.basePath + '/Customer/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Customer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Customer");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<Customer>> {
        const localVarPath = this.basePath + '/Customers/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Customer>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Customer>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<Customer>> {
        const localVarPath = this.basePath + '/Customers/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Customer>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Customer>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: Customer) : Promise<Customer> {
        const localVarPath = this.basePath + '/Customer';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Customer")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Customer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Customer");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum DocumentApiApiKeys {
}

export class DocumentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DocumentApiApiKeys, value: string) {
        (this.authentications as any)[DocumentApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Document/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param IDComment ID of record
     * @param IDDocument ID of record
     */
    public addCommentsToDocument (IDComment: number, IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/Document/{IDDocument}/Comment/Add/{IDComment}'
            .replace('{' + 'IDComment' + '}', encodeURIComponent(String(IDComment)))
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDComment' is not null or undefined
        if (IDComment === null || IDComment === undefined) {
            throw new Error('Required parameter IDComment was null or undefined when calling addCommentsToDocument.');
        }

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling addCommentsToDocument.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in addCommentsToDocument!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param IDObservation ID of record
     * @param IDDocument ID of record
     */
    public addDocumentObservation (IDObservation: number, IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/Document/{IDDocument}/AddObservation/{IDObservation}'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)))
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling addDocumentObservation.');
        }

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling addDocumentObservation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in addDocumentObservation!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Documents/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Documents/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: DocumentModel) : Promise<DocumentModel> {
        const localVarPath = this.basePath + '/Document';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DocumentModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<DocumentModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DocumentModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Get Document count form beginning of month in Customer timezone UP TO target DocumentID
     * @param IDDocument ID of record
     */
    public getDocumentCountBySequenceNumber (IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/Document/{IDDocument}/SequenceNumber/Monthly'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling getDocumentCountBySequenceNumber.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getDocumentCountBySequenceNumber!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Generate a DCR in HTML format
     * @param IDDocument ID of record
     */
    public getDocumentHTML (IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/Document/{IDDocument}/DCR.html'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling getDocumentHTML.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getDocumentHTML!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Generate a DCR in JSON format
     * @param IDDocument ID of record
     */
    public getDocumentJSON (IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/Document/{IDDocument}/DCR.json'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling getDocumentJSON.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getDocumentJSON!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Generate a DCR in PDF format
     * @param IDDocument ID of record
     */
    public getDocumentPDF (IDDocument: number) : Promise<Buffer> {
        const localVarPath = this.basePath + '/Document/{IDDocument}/DCR.pdf'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling getDocumentPDF.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Buffer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Buffer");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getDocumentPDF!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Get Report Parameters that being sent to the report service
     * @param IDDocument ID of record
     */
    public getDocumentReportParameters (IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/Document/{IDDocument}/ReportParameters'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling getDocumentReportParameters.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getDocumentReportParameters!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Document/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<DocumentModel>> {
        const localVarPath = this.basePath + '/Document/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<DocumentModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<DocumentModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<DocumentModel> {
        const localVarPath = this.basePath + '/Document/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<DocumentModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DocumentModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<DocumentModel>> {
        const localVarPath = this.basePath + '/Documents/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<DocumentModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<DocumentModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<DocumentModel>> {
        const localVarPath = this.basePath + '/Documents/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<DocumentModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<DocumentModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param IDObservation ID of record
     * @param IDDocument ID of record
     */
    public removeDocumentObservation (IDObservation: number, IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/Document/{IDDocument}/RemoveObservation/{IDObservation}'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)))
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling removeDocumentObservation.');
        }

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling removeDocumentObservation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in removeDocumentObservation!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Attach an ElectronicSignature to a Document
     * @param IDElectronicSignature ID of record
     * @param IDDocument ID of record
     */
    public signDocument (IDElectronicSignature: number, IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/Document/Sign/{IDDocument}/{IDElectronicSignature}'
            .replace('{' + 'IDElectronicSignature' + '}', encodeURIComponent(String(IDElectronicSignature)))
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDElectronicSignature' is not null or undefined
        if (IDElectronicSignature === null || IDElectronicSignature === undefined) {
            throw new Error('Required parameter IDElectronicSignature was null or undefined when calling signDocument.');
        }

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling signDocument.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in signDocument!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * UNDelete a specific Document
     * @param IDDocument ID of record
     */
    public undeleteDocument (IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/Document/Undelete/{IDDocument}'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling undeleteDocument.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in undeleteDocument!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: DocumentModel) : Promise<DocumentModel> {
        const localVarPath = this.basePath + '/Document';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DocumentModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<DocumentModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DocumentModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Update Document ExternalSyncDate field
     */
    public updateDocumentExternalSyncDate () : Promise<any> {
        const localVarPath = this.basePath + '/Document/UpdateExternalSyncDate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in updateDocumentExternalSyncDate!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum DocumentApprovalApiApiKeys {
}

export class DocumentApprovalApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DocumentApprovalApiApiKeys, value: string) {
        (this.authentications as any)[DocumentApprovalApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get list of Approvers for Document
     * @param IDDocument ID of record
     */
    public getDocumentApproverList (IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/DocumentApproval/{IDDocument}/ApproverList'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling getDocumentApproverList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getDocumentApproverList!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Get current Approval state of Document, and available actions for respective user as it relates to that state
     * @param IDDocument ID of record
     */
    public getDocumentState (IDDocument: number) : Promise<any> {
        const localVarPath = this.basePath + '/DocumentApproval/{IDDocument}/State'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling getDocumentState.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getDocumentState!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Perform Approval state transition action against Document
     * @param body 
     */
    public postChangeDocumenttState (body: DocumentStateChangeRequest) : Promise<any> {
        const localVarPath = this.basePath + '/DocumentApproval';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postChangeDocumenttState.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DocumentStateChangeRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postChangeDocumenttState!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum DocumentSendToApiApiKeys {
}

export class DocumentSendToApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DocumentSendToApiApiKeys, value: string) {
        (this.authentications as any)[DocumentSendToApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param IDDocument ID of record
     * @param body 
     */
    public postDocumentSendToEmail (IDDocument: number, body: SendToEmailRequest) : Promise<any> {
        const localVarPath = this.basePath + '/DocumentSendTo/{IDDocument}/Email'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling postDocumentSendToEmail.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postDocumentSendToEmail.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SendToEmailRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postDocumentSendToEmail!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum DocumentsApiApiKeys {
}

export class DocumentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DocumentsApiApiKeys, value: string) {
        (this.authentications as any)[DocumentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get all Document records for this user that have changed since the sync date
     * @param SynchronizeFromDate FROM date (descending)
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    public getUpdatedDocuments (SynchronizeFromDate: Date, Begin: number, Cap: number) : Promise<any> {
        const localVarPath = this.basePath + '/Documents/Sync/{SynchronizeFromDate}/{Begin}/{Cap}'
            .replace('{' + 'SynchronizeFromDate' + '}', encodeURIComponent(String(SynchronizeFromDate)))
            .replace('{' + 'Begin' + '}', encodeURIComponent(String(Begin)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'SynchronizeFromDate' is not null or undefined
        if (SynchronizeFromDate === null || SynchronizeFromDate === undefined) {
            throw new Error('Required parameter SynchronizeFromDate was null or undefined when calling getUpdatedDocuments.');
        }

        // verify required parameter 'Begin' is not null or undefined
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling getUpdatedDocuments.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getUpdatedDocuments.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getUpdatedDocuments!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Sync Documents  Process (since this is so complex): 1. FOR EACH Document     1.1 Archive the Document     1.2 Merge in the Changes     1.5 After all Detail records are successfully stored, Update Document so Document.definition contains the serialized array of Details 2. Get all Document records for this user that have changed since the sync date
     * @param SynchronizeFromDate FROM date (descending)
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    public syncDocuments (SynchronizeFromDate: Date, Begin: number, Cap: number) : Promise<any> {
        const localVarPath = this.basePath + '/Documents/Sync/{SynchronizeFromDate}/{Begin}/{Cap}'
            .replace('{' + 'SynchronizeFromDate' + '}', encodeURIComponent(String(SynchronizeFromDate)))
            .replace('{' + 'Begin' + '}', encodeURIComponent(String(Begin)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'SynchronizeFromDate' is not null or undefined
        if (SynchronizeFromDate === null || SynchronizeFromDate === undefined) {
            throw new Error('Required parameter SynchronizeFromDate was null or undefined when calling syncDocuments.');
        }

        // verify required parameter 'Begin' is not null or undefined
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling syncDocuments.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling syncDocuments.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in syncDocuments!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum DocumentsByObservationApiApiKeys {
}

export class DocumentsByObservationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DocumentsByObservationApiApiKeys, value: string) {
        (this.authentications as any)[DocumentsByObservationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param IDObservation ID of record
     */
    public getDocumentByObservation (IDObservation: number) : Promise<any> {
        const localVarPath = this.basePath + '/DocumentsByObservation/{IDObservation}'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling getDocumentByObservation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getDocumentByObservation!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ElectronicSignatureApiApiKeys {
}

export class ElectronicSignatureApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ElectronicSignatureApiApiKeys, value: string) {
        (this.authentications as any)[ElectronicSignatureApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/ElectronicSignature/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ElectronicSignatures/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ElectronicSignatures/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: ElectronicSignatureModel) : Promise<ElectronicSignatureModel> {
        const localVarPath = this.basePath + '/ElectronicSignature';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ElectronicSignatureModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ElectronicSignatureModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ElectronicSignatureModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ElectronicSignature/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<ElectronicSignatureModel>> {
        const localVarPath = this.basePath + '/ElectronicSignature/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ElectronicSignatureModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ElectronicSignatureModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<ElectronicSignatureModel> {
        const localVarPath = this.basePath + '/ElectronicSignature/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ElectronicSignatureModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ElectronicSignatureModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<ElectronicSignatureModel>> {
        const localVarPath = this.basePath + '/ElectronicSignatures/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ElectronicSignatureModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ElectronicSignatureModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<ElectronicSignatureModel>> {
        const localVarPath = this.basePath + '/ElectronicSignatures/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ElectronicSignatureModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ElectronicSignatureModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: ElectronicSignatureModel) : Promise<ElectronicSignatureModel> {
        const localVarPath = this.basePath + '/ElectronicSignature';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ElectronicSignatureModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ElectronicSignatureModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ElectronicSignatureModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum EquipmentApiApiKeys {
}

export class EquipmentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EquipmentApiApiKeys, value: string) {
        (this.authentications as any)[EquipmentApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Equipment/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Equipments/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Equipments/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: Equipment) : Promise<Equipment> {
        const localVarPath = this.basePath + '/Equipment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Equipment")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Equipment>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Equipment");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Equipment/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<Equipment>> {
        const localVarPath = this.basePath + '/Equipment/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Equipment>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Equipment>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<Equipment> {
        const localVarPath = this.basePath + '/Equipment/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Equipment>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Equipment");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<Equipment>> {
        const localVarPath = this.basePath + '/Equipments/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Equipment>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Equipment>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<Equipment>> {
        const localVarPath = this.basePath + '/Equipments/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Equipment>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Equipment>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: Equipment) : Promise<Equipment> {
        const localVarPath = this.basePath + '/Equipment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Equipment")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Equipment>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Equipment");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum LabApiApiKeys {
}

export class LabApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LabApiApiKeys, value: string) {
        (this.authentications as any)[LabApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Lab/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Labs/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Labs/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: Lab) : Promise<Lab> {
        const localVarPath = this.basePath + '/Lab';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Lab")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Lab>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Lab");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Lab/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<Lab>> {
        const localVarPath = this.basePath + '/Lab/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Lab>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Lab>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<Lab> {
        const localVarPath = this.basePath + '/Lab/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Lab>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Lab");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<Lab>> {
        const localVarPath = this.basePath + '/Labs/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Lab>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Lab>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<Lab>> {
        const localVarPath = this.basePath + '/Labs/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Lab>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Lab>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: Lab) : Promise<Lab> {
        const localVarPath = this.basePath + '/Lab';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Lab")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Lab>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Lab");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum LabMaterialAssignmentApiApiKeys {
}

export class LabMaterialAssignmentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LabMaterialAssignmentApiApiKeys, value: string) {
        (this.authentications as any)[LabMaterialAssignmentApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/LabMaterialAssignment/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LabMaterialAssignments/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LabMaterialAssignments/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: LabMaterialAssignment) : Promise<LabMaterialAssignment> {
        const localVarPath = this.basePath + '/LabMaterialAssignment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "LabMaterialAssignment")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LabMaterialAssignment>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LabMaterialAssignment");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LabMaterialAssignment/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<LabMaterialAssignment>> {
        const localVarPath = this.basePath + '/LabMaterialAssignment/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LabMaterialAssignment>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LabMaterialAssignment>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<LabMaterialAssignment> {
        const localVarPath = this.basePath + '/LabMaterialAssignment/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LabMaterialAssignment>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LabMaterialAssignment");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<LabMaterialAssignment>> {
        const localVarPath = this.basePath + '/LabMaterialAssignments/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LabMaterialAssignment>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LabMaterialAssignment>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<LabMaterialAssignment>> {
        const localVarPath = this.basePath + '/LabMaterialAssignments/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LabMaterialAssignment>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LabMaterialAssignment>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: LabMaterialAssignment) : Promise<LabMaterialAssignment> {
        const localVarPath = this.basePath + '/LabMaterialAssignment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "LabMaterialAssignment")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LabMaterialAssignment>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LabMaterialAssignment");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum LabTestApprovalApiApiKeys {
}

export class LabTestApprovalApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LabTestApprovalApiApiKeys, value: string) {
        (this.authentications as any)[LabTestApprovalApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/LabTestApproval/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LabTestApprovals/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LabTestApprovals/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: LabTestApproval) : Promise<LabTestApproval> {
        const localVarPath = this.basePath + '/LabTestApproval';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "LabTestApproval")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LabTestApproval>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LabTestApproval");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LabTestApproval/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<LabTestApproval>> {
        const localVarPath = this.basePath + '/LabTestApproval/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LabTestApproval>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LabTestApproval>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<LabTestApproval> {
        const localVarPath = this.basePath + '/LabTestApproval/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LabTestApproval>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LabTestApproval");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<LabTestApproval>> {
        const localVarPath = this.basePath + '/LabTestApprovals/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LabTestApproval>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LabTestApproval>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<LabTestApproval>> {
        const localVarPath = this.basePath + '/LabTestApprovals/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LabTestApproval>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LabTestApproval>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: LabTestApproval) : Promise<LabTestApproval> {
        const localVarPath = this.basePath + '/LabTestApproval';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "LabTestApproval")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LabTestApproval>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LabTestApproval");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum LabTestDefaultApiApiKeys {
}

export class LabTestDefaultApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LabTestDefaultApiApiKeys, value: string) {
        (this.authentications as any)[LabTestDefaultApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/LabTestDefault/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LabTestDefaults/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LabTestDefaults/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: LabTestDefault) : Promise<LabTestDefault> {
        const localVarPath = this.basePath + '/LabTestDefault';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "LabTestDefault")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LabTestDefault>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LabTestDefault");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LabTestDefault/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<LabTestDefault>> {
        const localVarPath = this.basePath + '/LabTestDefault/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LabTestDefault>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LabTestDefault>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<LabTestDefault> {
        const localVarPath = this.basePath + '/LabTestDefault/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LabTestDefault>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LabTestDefault");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<LabTestDefault>> {
        const localVarPath = this.basePath + '/LabTestDefaults/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LabTestDefault>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LabTestDefault>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<LabTestDefault>> {
        const localVarPath = this.basePath + '/LabTestDefaults/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LabTestDefault>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LabTestDefault>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: LabTestDefault) : Promise<LabTestDefault> {
        const localVarPath = this.basePath + '/LabTestDefault';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "LabTestDefault")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LabTestDefault>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LabTestDefault");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum LineItemApiApiKeys {
}

export class LineItemApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LineItemApiApiKeys, value: string) {
        (this.authentications as any)[LineItemApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/LineItem/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LineItems/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LineItems/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: LineItem) : Promise<LineItem> {
        const localVarPath = this.basePath + '/LineItem';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "LineItem")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LineItem>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LineItem");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/LineItem/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<LineItem>> {
        const localVarPath = this.basePath + '/LineItem/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LineItem>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LineItem>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<LineItem> {
        const localVarPath = this.basePath + '/LineItem/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LineItem>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LineItem");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<LineItem>> {
        const localVarPath = this.basePath + '/LineItems/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LineItem>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LineItem>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<LineItem>> {
        const localVarPath = this.basePath + '/LineItems/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<LineItem>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<LineItem>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: LineItem) : Promise<LineItem> {
        const localVarPath = this.basePath + '/LineItem';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "LineItem")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<LineItem>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LineItem");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum MaterialApiApiKeys {
}

export class MaterialApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MaterialApiApiKeys, value: string) {
        (this.authentications as any)[MaterialApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Material/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Materials/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Materials/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: Material) : Promise<Material> {
        const localVarPath = this.basePath + '/Material';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Material")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Material>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Material");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Material/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<Material>> {
        const localVarPath = this.basePath + '/Material/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Material>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Material>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<Material> {
        const localVarPath = this.basePath + '/Material/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Material>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Material");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<Material>> {
        const localVarPath = this.basePath + '/Materials/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Material>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Material>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<Material>> {
        const localVarPath = this.basePath + '/Materials/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Material>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Material>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: Material) : Promise<Material> {
        const localVarPath = this.basePath + '/Material';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Material")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Material>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Material");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum MaterialLineItemJoinApiApiKeys {
}

export class MaterialLineItemJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MaterialLineItemJoinApiApiKeys, value: string) {
        (this.authentications as any)[MaterialLineItemJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/MaterialLineItemJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MaterialLineItemJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MaterialLineItemJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: MaterialLineItemJoin) : Promise<MaterialLineItemJoin> {
        const localVarPath = this.basePath + '/MaterialLineItemJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MaterialLineItemJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MaterialLineItemJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MaterialLineItemJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MaterialLineItemJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<MaterialLineItemJoin>> {
        const localVarPath = this.basePath + '/MaterialLineItemJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MaterialLineItemJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MaterialLineItemJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<MaterialLineItemJoin> {
        const localVarPath = this.basePath + '/MaterialLineItemJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MaterialLineItemJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MaterialLineItemJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<MaterialLineItemJoin>> {
        const localVarPath = this.basePath + '/MaterialLineItemJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MaterialLineItemJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MaterialLineItemJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<MaterialLineItemJoin>> {
        const localVarPath = this.basePath + '/MaterialLineItemJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MaterialLineItemJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MaterialLineItemJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: MaterialLineItemJoin) : Promise<MaterialLineItemJoin> {
        const localVarPath = this.basePath + '/MaterialLineItemJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MaterialLineItemJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MaterialLineItemJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MaterialLineItemJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum MaterialPayItemJoinApiApiKeys {
}

export class MaterialPayItemJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MaterialPayItemJoinApiApiKeys, value: string) {
        (this.authentications as any)[MaterialPayItemJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/MaterialPayItemJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MaterialPayItemJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MaterialPayItemJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: MaterialPayItemJoin) : Promise<MaterialPayItemJoin> {
        const localVarPath = this.basePath + '/MaterialPayItemJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MaterialPayItemJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MaterialPayItemJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MaterialPayItemJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MaterialPayItemJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<MaterialPayItemJoin>> {
        const localVarPath = this.basePath + '/MaterialPayItemJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MaterialPayItemJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MaterialPayItemJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<MaterialPayItemJoin> {
        const localVarPath = this.basePath + '/MaterialPayItemJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MaterialPayItemJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MaterialPayItemJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<MaterialPayItemJoin>> {
        const localVarPath = this.basePath + '/MaterialPayItemJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MaterialPayItemJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MaterialPayItemJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<MaterialPayItemJoin>> {
        const localVarPath = this.basePath + '/MaterialPayItemJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MaterialPayItemJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MaterialPayItemJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: MaterialPayItemJoin) : Promise<MaterialPayItemJoin> {
        const localVarPath = this.basePath + '/MaterialPayItemJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MaterialPayItemJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MaterialPayItemJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MaterialPayItemJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum MaterialRecordOfMaterialEntryJoinApiApiKeys {
}

export class MaterialRecordOfMaterialEntryJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MaterialRecordOfMaterialEntryJoinApiApiKeys, value: string) {
        (this.authentications as any)[MaterialRecordOfMaterialEntryJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/MaterialRecordOfMaterialEntryJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MaterialRecordOfMaterialEntryJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MaterialRecordOfMaterialEntryJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: MaterialRecordOfMaterialEntryJoin) : Promise<MaterialRecordOfMaterialEntryJoin> {
        const localVarPath = this.basePath + '/MaterialRecordOfMaterialEntryJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MaterialRecordOfMaterialEntryJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MaterialRecordOfMaterialEntryJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MaterialRecordOfMaterialEntryJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MaterialRecordOfMaterialEntryJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<MaterialRecordOfMaterialEntryJoin>> {
        const localVarPath = this.basePath + '/MaterialRecordOfMaterialEntryJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MaterialRecordOfMaterialEntryJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MaterialRecordOfMaterialEntryJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<MaterialRecordOfMaterialEntryJoin> {
        const localVarPath = this.basePath + '/MaterialRecordOfMaterialEntryJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MaterialRecordOfMaterialEntryJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MaterialRecordOfMaterialEntryJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<MaterialRecordOfMaterialEntryJoin>> {
        const localVarPath = this.basePath + '/MaterialRecordOfMaterialEntryJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MaterialRecordOfMaterialEntryJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MaterialRecordOfMaterialEntryJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<MaterialRecordOfMaterialEntryJoin>> {
        const localVarPath = this.basePath + '/MaterialRecordOfMaterialEntryJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MaterialRecordOfMaterialEntryJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MaterialRecordOfMaterialEntryJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: MaterialRecordOfMaterialEntryJoin) : Promise<MaterialRecordOfMaterialEntryJoin> {
        const localVarPath = this.basePath + '/MaterialRecordOfMaterialEntryJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MaterialRecordOfMaterialEntryJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MaterialRecordOfMaterialEntryJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MaterialRecordOfMaterialEntryJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum MixSpecificationApiApiKeys {
}

export class MixSpecificationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MixSpecificationApiApiKeys, value: string) {
        (this.authentications as any)[MixSpecificationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/MixSpecification/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MixSpecifications/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MixSpecifications/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: MixSpecification) : Promise<MixSpecification> {
        const localVarPath = this.basePath + '/MixSpecification';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MixSpecification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MixSpecification>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MixSpecification");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MixSpecification/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<MixSpecification>> {
        const localVarPath = this.basePath + '/MixSpecification/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MixSpecification>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MixSpecification>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<MixSpecification> {
        const localVarPath = this.basePath + '/MixSpecification/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MixSpecification>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MixSpecification");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<MixSpecification>> {
        const localVarPath = this.basePath + '/MixSpecifications/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MixSpecification>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MixSpecification>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<MixSpecification>> {
        const localVarPath = this.basePath + '/MixSpecifications/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MixSpecification>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MixSpecification>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: MixSpecification) : Promise<MixSpecification> {
        const localVarPath = this.basePath + '/MixSpecification';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MixSpecification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MixSpecification>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MixSpecification");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum MixSpecificationMaterialJoinApiApiKeys {
}

export class MixSpecificationMaterialJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MixSpecificationMaterialJoinApiApiKeys, value: string) {
        (this.authentications as any)[MixSpecificationMaterialJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/MixSpecificationMaterialJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MixSpecificationMaterialJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MixSpecificationMaterialJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: MixSpecificationMaterialJoin) : Promise<MixSpecificationMaterialJoin> {
        const localVarPath = this.basePath + '/MixSpecificationMaterialJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MixSpecificationMaterialJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MixSpecificationMaterialJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MixSpecificationMaterialJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/MixSpecificationMaterialJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<MixSpecificationMaterialJoin>> {
        const localVarPath = this.basePath + '/MixSpecificationMaterialJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MixSpecificationMaterialJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MixSpecificationMaterialJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<MixSpecificationMaterialJoin> {
        const localVarPath = this.basePath + '/MixSpecificationMaterialJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MixSpecificationMaterialJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MixSpecificationMaterialJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<MixSpecificationMaterialJoin>> {
        const localVarPath = this.basePath + '/MixSpecificationMaterialJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MixSpecificationMaterialJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MixSpecificationMaterialJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<MixSpecificationMaterialJoin>> {
        const localVarPath = this.basePath + '/MixSpecificationMaterialJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<MixSpecificationMaterialJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<MixSpecificationMaterialJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: MixSpecificationMaterialJoin) : Promise<MixSpecificationMaterialJoin> {
        const localVarPath = this.basePath + '/MixSpecificationMaterialJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MixSpecificationMaterialJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<MixSpecificationMaterialJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "MixSpecificationMaterialJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ModuleApiApiKeys {
}

export class ModuleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ModuleApiApiKeys, value: string) {
        (this.authentications as any)[ModuleApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Module/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Modules/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Modules/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: ModuleModel) : Promise<ModuleModel> {
        const localVarPath = this.basePath + '/Module';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ModuleModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ModuleModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ModuleModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Module/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<ModuleModel>> {
        const localVarPath = this.basePath + '/Module/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ModuleModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ModuleModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<ModuleModel> {
        const localVarPath = this.basePath + '/Module/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ModuleModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ModuleModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<ModuleModel>> {
        const localVarPath = this.basePath + '/Modules/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ModuleModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ModuleModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<ModuleModel>> {
        const localVarPath = this.basePath + '/Modules/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ModuleModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ModuleModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: ModuleModel) : Promise<ModuleModel> {
        const localVarPath = this.basePath + '/Module';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ModuleModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ModuleModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ModuleModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum NotificationApiApiKeys {
}

export class NotificationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NotificationApiApiKeys, value: string) {
        (this.authentications as any)[NotificationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Notification/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Notifications/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Notifications/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: Notification) : Promise<Notification> {
        const localVarPath = this.basePath + '/Notification';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Notification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Notification>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Notification");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Notification/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<Notification>> {
        const localVarPath = this.basePath + '/Notification/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Notification>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Notification>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<Notification> {
        const localVarPath = this.basePath + '/Notification/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Notification>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Notification");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<Notification>> {
        const localVarPath = this.basePath + '/Notifications/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Notification>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Notification>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<Notification>> {
        const localVarPath = this.basePath + '/Notifications/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Notification>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Notification>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: Notification) : Promise<Notification> {
        const localVarPath = this.basePath + '/Notification';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Notification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Notification>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Notification");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ObservationApiApiKeys {
}

export class ObservationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ObservationApiApiKeys, value: string) {
        (this.authentications as any)[ObservationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Observation/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Index all Observations for a single day (solr)
     * @param SynchronizeByDay 
     */
    public beginIndexByDay (SynchronizeByDay: string) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationSearchSyncByDay/{SynchronizeByDay}'
            .replace('{' + 'SynchronizeByDay' + '}', encodeURIComponent(String(SynchronizeByDay)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'SynchronizeByDay' is not null or undefined
        if (SynchronizeByDay === null || SynchronizeByDay === undefined) {
            throw new Error('Required parameter SynchronizeByDay was null or undefined when calling beginIndexByDay.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in beginIndexByDay!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Index all Observations for a single project (solr)
     * @param IDProject ID of record
     */
    public beginIndexByProject (IDProject: number) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationSearchSyncByProject/{IDProject}'
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling beginIndexByProject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in beginIndexByProject!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Delete and rebuild entire Observation search index (solr)
     */
    public beginObservationSearchRebuild () : Promise<any> {
        const localVarPath = this.basePath + '/ObservationSearchRebuild';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in beginObservationSearchRebuild!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Observations/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Observations/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: ObservationModel) : Promise<ObservationModel> {
        const localVarPath = this.basePath + '/Observation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ObservationModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ObservationModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ObservationModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param IDProject ID of record
     * @param SpritePageNumber 
     */
    public downloadObservationCollectionImage (IDProject: number, SpritePageNumber: number) : Promise<Buffer> {
        const localVarPath = this.basePath + '/Observation/Project/{IDProject}/Sprites/{SpritePageNumber}'
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)))
            .replace('{' + 'SpritePageNumber' + '}', encodeURIComponent(String(SpritePageNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling downloadObservationCollectionImage.');
        }

        // verify required parameter 'SpritePageNumber' is not null or undefined
        if (SpritePageNumber === null || SpritePageNumber === undefined) {
            throw new Error('Required parameter SpritePageNumber was null or undefined when calling downloadObservationCollectionImage.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Buffer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Buffer");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in downloadObservationCollectionImage!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Download Observation Image - Get transcoded media file for an observation. If not found, asks transcoder to regenerate it
     * @param IDObservation ID of record
     * @param Size e.g. Thumbnail,Standard,Preview,Enhanced
     */
    public downloadObservationImage (IDObservation: number, Size: string) : Promise<Buffer> {
        const localVarPath = this.basePath + '/Observation/{IDObservation}/Image/{Size}'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)))
            .replace('{' + 'Size' + '}', encodeURIComponent(String(Size)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling downloadObservationImage.');
        }

        // verify required parameter 'Size' is not null or undefined
        if (Size === null || Size === undefined) {
            throw new Error('Required parameter Size was null or undefined when calling downloadObservationImage.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Buffer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Buffer");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in downloadObservationImage!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Get Observation Image Hash - Get time on observation media item from mongo.
     * @param Size e.g. Thumbnail,Standard,Preview,Enhanced
     * @param Version 
     */
    public getObservationImageHash (Size: string, Version: number) : Promise<any> {
        const localVarPath = this.basePath + '/Observation/ImageHash/{Size}/V/{Version}'
            .replace('{' + 'Size' + '}', encodeURIComponent(String(Size)))
            .replace('{' + 'Version' + '}', encodeURIComponent(String(Version)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'Size' is not null or undefined
        if (Size === null || Size === undefined) {
            throw new Error('Required parameter Size was null or undefined when calling getObservationImageHash.');
        }

        // verify required parameter 'Version' is not null or undefined
        if (Version === null || Version === undefined) {
            throw new Error('Required parameter Version was null or undefined when calling getObservationImageHash.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationImageHash!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param SynchronizeFromDate 
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    public getUpdatedObservations (SynchronizeFromDate: Date, Begin: number, Cap: number) : Promise<Array<ObservationModel>> {
        const localVarPath = this.basePath + '/Observations/Sync/{SynchronizeFromDate}/{Begin}/{Cap}'
            .replace('{' + 'SynchronizeFromDate' + '}', encodeURIComponent(String(SynchronizeFromDate)))
            .replace('{' + 'Begin' + '}', encodeURIComponent(String(Begin)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'SynchronizeFromDate' is not null or undefined
        if (SynchronizeFromDate === null || SynchronizeFromDate === undefined) {
            throw new Error('Required parameter SynchronizeFromDate was null or undefined when calling getUpdatedObservations.');
        }

        // verify required parameter 'Begin' is not null or undefined
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling getUpdatedObservations.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getUpdatedObservations.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ObservationModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ObservationModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getUpdatedObservations!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * postCloneBulkObservations API
     * @param body 
     */
    public postCloneBulkObservations (body: ObservationCloneRequest) : Promise<Array<ObservationModel>> {
        const localVarPath = this.basePath + '/Observations/Clone';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postCloneBulkObservations.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ObservationCloneRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ObservationModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ObservationModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postCloneBulkObservations!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * postCloneObservation API
     * @param IDObservation ID of record
     */
    public postCloneObservation (IDObservation: number) : Promise<ObservationModel> {
        const localVarPath = this.basePath + '/Observation/{IDObservation}/Clone'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling postCloneObservation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ObservationModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ObservationModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postCloneObservation!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Add a tag to a set of Observations (by ID)
     */
    public postObservationsBatchTagAdd () : Promise<any> {
        const localVarPath = this.basePath + '/ObservationsBatchTag/Add';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postObservationsBatchTagAdd!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Remove a tag to a set of Observations (by ID)
     */
    public postObservationsBatchTagRemove () : Promise<any> {
        const localVarPath = this.basePath + '/ObservationsBatchTag/Remove';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postObservationsBatchTagRemove!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Observation/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<ObservationModel>> {
        const localVarPath = this.basePath + '/Observation/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ObservationModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ObservationModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Index specific Observations (solr)
     * @param IDObservation ID of record
     */
    public pushObservationSearchIndexByIDs (IDObservation: number) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationSearchSyncByID/{IDObservation}'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling pushObservationSearchIndexByIDs.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in pushObservationSearchIndexByIDs!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<ObservationModel> {
        const localVarPath = this.basePath + '/Observation/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ObservationModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ObservationModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<ObservationModel>> {
        const localVarPath = this.basePath + '/Observations/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ObservationModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ObservationModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<ObservationModel>> {
        const localVarPath = this.basePath + '/Observations/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ObservationModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ObservationModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Sync Observations  Process (since this is so complex): 1. FOR EACH OBSERVATION     1.1 Archive the Observation     1.2 Merge in the Changes     1.3 Translate the Observation Details     1.4 PERFORM SYNC MATCH AND UPDATE WHERE NECESSARY (TALK TO TRENT)     1.5 After all Detail records are successfully stored, Update Observation so Observation.definition contains the serialized array of Details 2. Get all observation records for this user that have changed since the sync date
     * @param SynchronizeFromDate 
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    public syncObservations (SynchronizeFromDate: Date, Begin: number, Cap: number) : Promise<any> {
        const localVarPath = this.basePath + '/Observations/Sync/{SynchronizeFromDate}/{Begin}/{Cap}'
            .replace('{' + 'SynchronizeFromDate' + '}', encodeURIComponent(String(SynchronizeFromDate)))
            .replace('{' + 'Begin' + '}', encodeURIComponent(String(Begin)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'SynchronizeFromDate' is not null or undefined
        if (SynchronizeFromDate === null || SynchronizeFromDate === undefined) {
            throw new Error('Required parameter SynchronizeFromDate was null or undefined when calling syncObservations.');
        }

        // verify required parameter 'Begin' is not null or undefined
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling syncObservations.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling syncObservations.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in syncObservations!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Touch Observation record UpdateDate and set Transcoded flag - When media files are updated, we want other devices to see the changes and pull it down
     * @param IDObservation ID of record
     */
    public transcodeTouchObservation (IDObservation: number) : Promise<any> {
        const localVarPath = this.basePath + '/Observation/{IDObservation}/TranscodeTouch'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling transcodeTouchObservation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in transcodeTouchObservation!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * UNDelete a specific observation
     * @param IDObservation ID of record
     */
    public undeleteObservation (IDObservation: number) : Promise<any> {
        const localVarPath = this.basePath + '/Observation/Undelete/{IDObservation}'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling undeleteObservation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in undeleteObservation!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: ObservationModel) : Promise<ObservationModel> {
        const localVarPath = this.basePath + '/Observation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ObservationModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ObservationModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ObservationModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ObservationApprovalApiApiKeys {
}

export class ObservationApprovalApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ObservationApprovalApiApiKeys, value: string) {
        (this.authentications as any)[ObservationApprovalApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get list of Approvers for Observation
     * @param IDObservation ID of record
     */
    public getObservationApproverList (IDObservation: number) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationApproval/{IDObservation}/ApproverList'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling getObservationApproverList.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationApproverList!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Get current Approval state of Observation, and available actions for respective user as it relates to that state
     * @param IDObservation ID of record
     */
    public getObservationState (IDObservation: number) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationApproval/{IDObservation}/State'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling getObservationState.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationState!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Perform Approval state transition action against Observation
     */
    public postChangeObservationtState () : Promise<any> {
        const localVarPath = this.basePath + '/ObservationApproval';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postChangeObservationtState!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ObservationCloneTemplatesApiApiKeys {
}

export class ObservationCloneTemplatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ObservationCloneTemplatesApiApiKeys, value: string) {
        (this.authentications as any)[ObservationCloneTemplatesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param IDProject ID of record
     */
    public getCloneTemplates (IDProject: number) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationCloneTemplates/{IDProject}'
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling getCloneTemplates.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getCloneTemplates!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ObservationSearchsApiApiKeys {
}

export class ObservationSearchsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ObservationSearchsApiApiKeys, value: string) {
        (this.authentications as any)[ObservationSearchsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Search Observations using search index (solr)
     * @param IDProject ID of record
     * @param Begin Beginning (skip) number of records (to page)
     * @param SearchQuery solr search query
     * @param Cap Maximum number of records to return
     */
    public getObservationSearch (IDProject: number, Begin: number, SearchQuery: string, Cap: number) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationSearchs/{IDProject}/{SearchQuery}/{Begin}/{Cap}'
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)))
            .replace('{' + 'Begin' + '}', encodeURIComponent(String(Begin)))
            .replace('{' + 'SearchQuery' + '}', encodeURIComponent(String(SearchQuery)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling getObservationSearch.');
        }

        // verify required parameter 'Begin' is not null or undefined
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling getObservationSearch.');
        }

        // verify required parameter 'SearchQuery' is not null or undefined
        if (SearchQuery === null || SearchQuery === undefined) {
            throw new Error('Required parameter SearchQuery was null or undefined when calling getObservationSearch.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getObservationSearch.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationSearch!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Search Observations using search index (solr)
     * @param IDProject ID of record
     * @param SearchQuery solr search query
     */
    public getObservationSearchCount (IDProject: number, SearchQuery: string) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationSearchs/Count/{IDProject}/{SearchQuery}'
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)))
            .replace('{' + 'SearchQuery' + '}', encodeURIComponent(String(SearchQuery)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling getObservationSearchCount.');
        }

        // verify required parameter 'SearchQuery' is not null or undefined
        if (SearchQuery === null || SearchQuery === undefined) {
            throw new Error('Required parameter SearchQuery was null or undefined when calling getObservationSearchCount.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationSearchCount!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ObservationSendToApiApiKeys {
}

export class ObservationSendToApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ObservationSendToApiApiKeys, value: string) {
        (this.authentications as any)[ObservationSendToApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param IDObservation ID of record
     * @param EmailAddress 
     */
    public getObservationSendToEmail (IDObservation: number, EmailAddress: string) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationSendTo/{IDObservation}/Email/{EmailAddress}'
            .replace('{' + 'IDObservation' + '}', encodeURIComponent(String(IDObservation)))
            .replace('{' + 'EmailAddress' + '}', encodeURIComponent(String(EmailAddress)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDObservation' is not null or undefined
        if (IDObservation === null || IDObservation === undefined) {
            throw new Error('Required parameter IDObservation was null or undefined when calling getObservationSendToEmail.');
        }

        // verify required parameter 'EmailAddress' is not null or undefined
        if (EmailAddress === null || EmailAddress === undefined) {
            throw new Error('Required parameter EmailAddress was null or undefined when calling getObservationSendToEmail.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationSendToEmail!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     */
    public postObservationSendToEmail () : Promise<any> {
        const localVarPath = this.basePath + '/ObservationSendTo/Email';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postObservationSendToEmail!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ObservationsBatchTagApiApiKeys {
}

export class ObservationsBatchTagApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ObservationsBatchTagApiApiKeys, value: string) {
        (this.authentications as any)[ObservationsBatchTagApiApiKeys[key]].apiKey = value;
    }
    /**
     * Add a tag to a set of Observations (by ID)
     */
    public postObservationsBatchTagAdd () : Promise<any> {
        const localVarPath = this.basePath + '/ObservationsBatchTag/Add';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postObservationsBatchTagAdd!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Remove a tag to a set of Observations (by ID)
     */
    public postObservationsBatchTagRemove () : Promise<any> {
        const localVarPath = this.basePath + '/ObservationsBatchTag/Remove';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postObservationsBatchTagRemove!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ObservationsByDocumentApiApiKeys {
}

export class ObservationsByDocumentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ObservationsByDocumentApiApiKeys, value: string) {
        (this.authentications as any)[ObservationsByDocumentApiApiKeys[key]].apiKey = value;
    }
    /**
     * Find all observations associated to a document.
     * @param IDDocument ID of record
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    public getObservationsByDocument (IDDocument: number, Begin: number, Cap: number) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationsByDocument/{IDDocument}/{Begin}/{Cap}'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)))
            .replace('{' + 'Begin' + '}', encodeURIComponent(String(Begin)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling getObservationsByDocument.');
        }

        // verify required parameter 'Begin' is not null or undefined
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling getObservationsByDocument.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getObservationsByDocument.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationsByDocument!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Find observations NOT associated to any documents.
     * @param IDProject ID of record
     * @param Cap Maximum number of records to return
     */
    public getObservationsByNoDocument (IDProject: number, Cap: number) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationsByNoDocument/{IDProject}/{Cap}'
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling getObservationsByNoDocument.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getObservationsByNoDocument.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationsByNoDocument!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ObservationsByUpdateDateApiApiKeys {
}

export class ObservationsByUpdateDateApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ObservationsByUpdateDateApiApiKeys, value: string) {
        (this.authentications as any)[ObservationsByUpdateDateApiApiKeys[key]].apiKey = value;
    }
    /**
     * Fetch list of observations where date is earlier than ByDate.
     * @param ByDate 
     * @param Cap Maximum number of records to return
     */
    public getObservationsByUpdateDate (ByDate: Date, Cap: number) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationsByUpdateDate/{ByDate}/{Cap}'
            .replace('{' + 'ByDate' + '}', encodeURIComponent(String(ByDate)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'ByDate' is not null or undefined
        if (ByDate === null || ByDate === undefined) {
            throw new Error('Required parameter ByDate was null or undefined when calling getObservationsByUpdateDate.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getObservationsByUpdateDate.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationsByUpdateDate!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ObservationsFilterApiApiKeys {
}

export class ObservationsFilterApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ObservationsFilterApiApiKeys, value: string) {
        (this.authentications as any)[ObservationsFilterApiApiKeys[key]].apiKey = value;
    }
    /**
     * Search Observations using search index (solr)
     * @param body 
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    public getObservationsFilter (body: ObservationFilterRequest, Begin: number, Cap: number) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationsFilter/{Begin}/{Cap}'
            .replace('{' + 'Begin' + '}', encodeURIComponent(String(Begin)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling getObservationsFilter.');
        }

        // verify required parameter 'Begin' is not null or undefined
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling getObservationsFilter.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getObservationsFilter.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ObservationFilterRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationsFilter!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Search Observations using search index (solr)
     * @param body 
     */
    public getObservationsFilterCount (body: ObservationFilterRequest) : Promise<any> {
        const localVarPath = this.basePath + '/ObservationsFilter/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling getObservationsFilterCount.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ObservationFilterRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getObservationsFilterCount!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum OrganizationApiApiKeys {
}

export class OrganizationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Organization/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Organizations/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Organizations/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: Organization) : Promise<Organization> {
        const localVarPath = this.basePath + '/Organization';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Organization")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Organization>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Organization");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Organization/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<Organization>> {
        const localVarPath = this.basePath + '/Organization/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Organization>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Organization>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<Organization> {
        const localVarPath = this.basePath + '/Organization/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Organization>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Organization");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<Organization>> {
        const localVarPath = this.basePath + '/Organizations/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Organization>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Organization>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<Organization>> {
        const localVarPath = this.basePath + '/Organizations/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Organization>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Organization>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: Organization) : Promise<Organization> {
        const localVarPath = this.basePath + '/Organization';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Organization")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Organization>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Organization");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum OrganizationMaterialJoinApiApiKeys {
}

export class OrganizationMaterialJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationMaterialJoinApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationMaterialJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/OrganizationMaterialJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/OrganizationMaterialJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/OrganizationMaterialJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: OrganizationMaterialJoin) : Promise<OrganizationMaterialJoin> {
        const localVarPath = this.basePath + '/OrganizationMaterialJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "OrganizationMaterialJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<OrganizationMaterialJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "OrganizationMaterialJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/OrganizationMaterialJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<OrganizationMaterialJoin>> {
        const localVarPath = this.basePath + '/OrganizationMaterialJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<OrganizationMaterialJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<OrganizationMaterialJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<OrganizationMaterialJoin> {
        const localVarPath = this.basePath + '/OrganizationMaterialJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<OrganizationMaterialJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "OrganizationMaterialJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<OrganizationMaterialJoin>> {
        const localVarPath = this.basePath + '/OrganizationMaterialJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<OrganizationMaterialJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<OrganizationMaterialJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<OrganizationMaterialJoin>> {
        const localVarPath = this.basePath + '/OrganizationMaterialJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<OrganizationMaterialJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<OrganizationMaterialJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: OrganizationMaterialJoin) : Promise<OrganizationMaterialJoin> {
        const localVarPath = this.basePath + '/OrganizationMaterialJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "OrganizationMaterialJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<OrganizationMaterialJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "OrganizationMaterialJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum PayItemApiApiKeys {
}

export class PayItemApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PayItemApiApiKeys, value: string) {
        (this.authentications as any)[PayItemApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/PayItem/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/PayItems/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/PayItems/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: PayItemModel) : Promise<PayItemModel> {
        const localVarPath = this.basePath + '/PayItem';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PayItemModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<PayItemModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "PayItemModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/PayItem/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<PayItemModel>> {
        const localVarPath = this.basePath + '/PayItem/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<PayItemModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<PayItemModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<PayItemModel> {
        const localVarPath = this.basePath + '/PayItem/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<PayItemModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "PayItemModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<PayItemModel>> {
        const localVarPath = this.basePath + '/PayItems/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<PayItemModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<PayItemModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<PayItemModel>> {
        const localVarPath = this.basePath + '/PayItems/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<PayItemModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<PayItemModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: PayItemModel) : Promise<PayItemModel> {
        const localVarPath = this.basePath + '/PayItem';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PayItemModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<PayItemModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "PayItemModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ProductApiApiKeys {
}

export class ProductApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProductApiApiKeys, value: string) {
        (this.authentications as any)[ProductApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Product/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Products/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Products/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: Product) : Promise<Product> {
        const localVarPath = this.basePath + '/Product';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Product")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Product>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Product");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Product/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<Product>> {
        const localVarPath = this.basePath + '/Product/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Product>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Product>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<Product> {
        const localVarPath = this.basePath + '/Product/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Product>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Product");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<Product>> {
        const localVarPath = this.basePath + '/Products/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Product>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Product>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<Product>> {
        const localVarPath = this.basePath + '/Products/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Product>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Product>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: Product) : Promise<Product> {
        const localVarPath = this.basePath + '/Product';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Product")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Product>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Product");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ProductionPlantApiApiKeys {
}

export class ProductionPlantApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProductionPlantApiApiKeys, value: string) {
        (this.authentications as any)[ProductionPlantApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/ProductionPlant/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ProductionPlants/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ProductionPlants/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: ProductionPlant) : Promise<ProductionPlant> {
        const localVarPath = this.basePath + '/ProductionPlant';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ProductionPlant")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ProductionPlant>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ProductionPlant");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ProductionPlant/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<ProductionPlant>> {
        const localVarPath = this.basePath + '/ProductionPlant/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ProductionPlant>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ProductionPlant>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<ProductionPlant> {
        const localVarPath = this.basePath + '/ProductionPlant/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ProductionPlant>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ProductionPlant");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<ProductionPlant>> {
        const localVarPath = this.basePath + '/ProductionPlants/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ProductionPlant>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ProductionPlant>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<ProductionPlant>> {
        const localVarPath = this.basePath + '/ProductionPlants/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ProductionPlant>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ProductionPlant>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: ProductionPlant) : Promise<ProductionPlant> {
        const localVarPath = this.basePath + '/ProductionPlant';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ProductionPlant")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ProductionPlant>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ProductionPlant");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ProductionPlantMaterialApprovalApiApiKeys {
}

export class ProductionPlantMaterialApprovalApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProductionPlantMaterialApprovalApiApiKeys, value: string) {
        (this.authentications as any)[ProductionPlantMaterialApprovalApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/ProductionPlantMaterialApproval/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ProductionPlantMaterialApprovals/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ProductionPlantMaterialApprovals/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: ProductionPlantMaterialApproval) : Promise<ProductionPlantMaterialApproval> {
        const localVarPath = this.basePath + '/ProductionPlantMaterialApproval';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ProductionPlantMaterialApproval")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ProductionPlantMaterialApproval>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ProductionPlantMaterialApproval");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ProductionPlantMaterialApproval/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<ProductionPlantMaterialApproval>> {
        const localVarPath = this.basePath + '/ProductionPlantMaterialApproval/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ProductionPlantMaterialApproval>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ProductionPlantMaterialApproval>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<ProductionPlantMaterialApproval> {
        const localVarPath = this.basePath + '/ProductionPlantMaterialApproval/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ProductionPlantMaterialApproval>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ProductionPlantMaterialApproval");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<ProductionPlantMaterialApproval>> {
        const localVarPath = this.basePath + '/ProductionPlantMaterialApprovals/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ProductionPlantMaterialApproval>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ProductionPlantMaterialApproval>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<ProductionPlantMaterialApproval>> {
        const localVarPath = this.basePath + '/ProductionPlantMaterialApprovals/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ProductionPlantMaterialApproval>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ProductionPlantMaterialApproval>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: ProductionPlantMaterialApproval) : Promise<ProductionPlantMaterialApproval> {
        const localVarPath = this.basePath + '/ProductionPlantMaterialApproval';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ProductionPlantMaterialApproval")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ProductionPlantMaterialApproval>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ProductionPlantMaterialApproval");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ProjectApiApiKeys {
}

export class ProjectApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProjectApiApiKeys, value: string) {
        (this.authentications as any)[ProjectApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Project/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Projects/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Projects/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: ProjectModel) : Promise<ProjectModel> {
        const localVarPath = this.basePath + '/Project';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ProjectModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ProjectModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ProjectModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Project/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<ProjectModel>> {
        const localVarPath = this.basePath + '/Project/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ProjectModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ProjectModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<ProjectModel> {
        const localVarPath = this.basePath + '/Project/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ProjectModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ProjectModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<ProjectModel>> {
        const localVarPath = this.basePath + '/Projects/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ProjectModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ProjectModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<ProjectModel>> {
        const localVarPath = this.basePath + '/Projects/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ProjectModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ProjectModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: ProjectModel) : Promise<ProjectModel> {
        const localVarPath = this.basePath + '/Project';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ProjectModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ProjectModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ProjectModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum RecordOfMaterialApiApiKeys {
}

export class RecordOfMaterialApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RecordOfMaterialApiApiKeys, value: string) {
        (this.authentications as any)[RecordOfMaterialApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/RecordOfMaterial/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/RecordOfMaterials/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/RecordOfMaterials/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: RecordOfMaterial) : Promise<RecordOfMaterial> {
        const localVarPath = this.basePath + '/RecordOfMaterial';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RecordOfMaterial")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<RecordOfMaterial>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RecordOfMaterial");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/RecordOfMaterial/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<RecordOfMaterial>> {
        const localVarPath = this.basePath + '/RecordOfMaterial/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<RecordOfMaterial>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<RecordOfMaterial>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<RecordOfMaterial> {
        const localVarPath = this.basePath + '/RecordOfMaterial/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<RecordOfMaterial>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RecordOfMaterial");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<RecordOfMaterial>> {
        const localVarPath = this.basePath + '/RecordOfMaterials/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<RecordOfMaterial>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<RecordOfMaterial>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<RecordOfMaterial>> {
        const localVarPath = this.basePath + '/RecordOfMaterials/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<RecordOfMaterial>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<RecordOfMaterial>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: RecordOfMaterial) : Promise<RecordOfMaterial> {
        const localVarPath = this.basePath + '/RecordOfMaterial';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RecordOfMaterial")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<RecordOfMaterial>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RecordOfMaterial");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum RecordOfMaterialEntryApiApiKeys {
}

export class RecordOfMaterialEntryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RecordOfMaterialEntryApiApiKeys, value: string) {
        (this.authentications as any)[RecordOfMaterialEntryApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntry/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntrys/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntrys/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: RecordOfMaterialEntry) : Promise<RecordOfMaterialEntry> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntry';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RecordOfMaterialEntry")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<RecordOfMaterialEntry>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RecordOfMaterialEntry");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntry/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<RecordOfMaterialEntry>> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntry/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<RecordOfMaterialEntry>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<RecordOfMaterialEntry>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<RecordOfMaterialEntry> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntry/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<RecordOfMaterialEntry>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RecordOfMaterialEntry");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<RecordOfMaterialEntry>> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntrys/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<RecordOfMaterialEntry>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<RecordOfMaterialEntry>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<RecordOfMaterialEntry>> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntrys/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<RecordOfMaterialEntry>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<RecordOfMaterialEntry>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: RecordOfMaterialEntry) : Promise<RecordOfMaterialEntry> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntry';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RecordOfMaterialEntry")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<RecordOfMaterialEntry>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RecordOfMaterialEntry");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum RecordOfMaterialEntryArchiveApiApiKeys {
}

export class RecordOfMaterialEntryArchiveApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RecordOfMaterialEntryArchiveApiApiKeys, value: string) {
        (this.authentications as any)[RecordOfMaterialEntryArchiveApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntryArchive/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntryArchives/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntryArchives/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: RecordOfMaterialEntryArchive) : Promise<RecordOfMaterialEntryArchive> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntryArchive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RecordOfMaterialEntryArchive")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<RecordOfMaterialEntryArchive>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RecordOfMaterialEntryArchive");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntryArchive/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<RecordOfMaterialEntryArchive>> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntryArchive/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<RecordOfMaterialEntryArchive>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<RecordOfMaterialEntryArchive>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<RecordOfMaterialEntryArchive> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntryArchive/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<RecordOfMaterialEntryArchive>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RecordOfMaterialEntryArchive");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<RecordOfMaterialEntryArchive>> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntryArchives/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<RecordOfMaterialEntryArchive>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<RecordOfMaterialEntryArchive>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<RecordOfMaterialEntryArchive>> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntryArchives/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<RecordOfMaterialEntryArchive>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<RecordOfMaterialEntryArchive>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: RecordOfMaterialEntryArchive) : Promise<RecordOfMaterialEntryArchive> {
        const localVarPath = this.basePath + '/RecordOfMaterialEntryArchive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RecordOfMaterialEntryArchive")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<RecordOfMaterialEntryArchive>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RecordOfMaterialEntryArchive");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ReportApiApiKeys {
}

export class ReportApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportApiApiKeys, value: string) {
        (this.authentications as any)[ReportApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Report/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Reports/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Reports/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: ReportModel) : Promise<ReportModel> {
        const localVarPath = this.basePath + '/Report';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ReportModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ReportModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ReportModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Get list of available render types for a document type. (pdf, html, etc.)
     * @param ReportType Report type name (e.g. &#39;DCR&#39;, &#39;Headlight-Daily&#39;, etc)
     */
    public getDocumentRenderByType (ReportType: string) : Promise<any> {
        const localVarPath = this.basePath + '/Report/{ReportType}'
            .replace('{' + 'ReportType' + '}', encodeURIComponent(String(ReportType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'ReportType' is not null or undefined
        if (ReportType === null || ReportType === undefined) {
            throw new Error('Required parameter ReportType was null or undefined when calling getDocumentRenderByType.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getDocumentRenderByType!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Request to render a report. To get rendered files, use getReportStageFile() Example HTML flow: 1. Request /Report/Render/1247/default 2. Extract GUIDReportDescription (i.e. \"0x5984be9c8b000000\") from response object. 3. Open a new browser tab to: /Report/0x5984be9c8b000000/ 4. Rendered html page will subsequently request assets (images, css, etc)
     * @param IDDocument ID of record
     * @param Renderer Render format (default, html, pdf, json, etc)
     */
    public getRenderReport (IDDocument: number, Renderer: string) : Promise<ReportRenderResult> {
        const localVarPath = this.basePath + '/Report/Render/{IDDocument}/{Renderer}'
            .replace('{' + 'IDDocument' + '}', encodeURIComponent(String(IDDocument)))
            .replace('{' + 'Renderer' + '}', encodeURIComponent(String(Renderer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDDocument' is not null or undefined
        if (IDDocument === null || IDDocument === undefined) {
            throw new Error('Required parameter IDDocument was null or undefined when calling getRenderReport.');
        }

        // verify required parameter 'Renderer' is not null or undefined
        if (Renderer === null || Renderer === undefined) {
            throw new Error('Required parameter Renderer was null or undefined when calling getRenderReport.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ReportRenderResult>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ReportRenderResult");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getRenderReport!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Source JSON datum used to generate the report.
     * @param ReportUUID UUID of completed report render.
     */
    public getReportDatum (ReportUUID: string) : Promise<any> {
        const localVarPath = this.basePath + '/Report/Datum/{ReportUUID}'
            .replace('{' + 'ReportUUID' + '}', encodeURIComponent(String(ReportUUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'ReportUUID' is not null or undefined
        if (ReportUUID === null || ReportUUID === undefined) {
            throw new Error('Required parameter ReportUUID was null or undefined when calling getReportDatum.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getReportDatum!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Manifest (JSON metadata file) about the rendered report. Includes information about other generated assets.
     * @param ReportUUID UUID of completed report render.
     */
    public getReportManifest (ReportUUID: string) : Promise<any> {
        const localVarPath = this.basePath + '/Report/Manifest/{ReportUUID}'
            .replace('{' + 'ReportUUID' + '}', encodeURIComponent(String(ReportUUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'ReportUUID' is not null or undefined
        if (ReportUUID === null || ReportUUID === undefined) {
            throw new Error('Required parameter ReportUUID was null or undefined when calling getReportManifest.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getReportManifest!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Get staged (rendered) file for a previously rendered report.
     * @param ReportUUID UUID of completed report render.
     * @param StageFilePath Subpath to file in rendered report stage dir
     */
    public getReportStageFile (ReportUUID: string, StageFilePath: string) : Promise<Buffer> {
        const localVarPath = this.basePath + '/Report/{ReportUUID}/{StageFilePath}'
            .replace('{' + 'ReportUUID' + '}', encodeURIComponent(String(ReportUUID)))
            .replace('{' + 'StageFilePath' + '}', encodeURIComponent(String(StageFilePath)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'ReportUUID' is not null or undefined
        if (ReportUUID === null || ReportUUID === undefined) {
            throw new Error('Required parameter ReportUUID was null or undefined when calling getReportStageFile.');
        }

        // verify required parameter 'StageFilePath' is not null or undefined
        if (StageFilePath === null || StageFilePath === undefined) {
            throw new Error('Required parameter StageFilePath was null or undefined when calling getReportStageFile.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Buffer>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Buffer");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getReportStageFile!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Report/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<ReportModel>> {
        const localVarPath = this.basePath + '/Report/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ReportModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ReportModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<ReportModel> {
        const localVarPath = this.basePath + '/Report/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ReportModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ReportModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<ReportModel>> {
        const localVarPath = this.basePath + '/Reports/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ReportModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ReportModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<ReportModel>> {
        const localVarPath = this.basePath + '/Reports/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ReportModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ReportModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: ReportModel) : Promise<ReportModel> {
        const localVarPath = this.basePath + '/Report';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ReportModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ReportModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ReportModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum ReportNamedInstanceApiApiKeys {
}

export class ReportNamedInstanceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportNamedInstanceApiApiKeys, value: string) {
        (this.authentications as any)[ReportNamedInstanceApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/ReportNamedInstance/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param IDProject ID of record
     * @param IDReportNamedInstance ID of record
     */
    public addReportNamedInstanceToProject (IDProject: number, IDReportNamedInstance: number) : Promise<any> {
        const localVarPath = this.basePath + '/ReportNamedInstance/{IDReportNamedInstance}/AddToProject/{IDProject}'
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)))
            .replace('{' + 'IDReportNamedInstance' + '}', encodeURIComponent(String(IDReportNamedInstance)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling addReportNamedInstanceToProject.');
        }

        // verify required parameter 'IDReportNamedInstance' is not null or undefined
        if (IDReportNamedInstance === null || IDReportNamedInstance === undefined) {
            throw new Error('Required parameter IDReportNamedInstance was null or undefined when calling addReportNamedInstanceToProject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in addReportNamedInstanceToProject!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ReportNamedInstances/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ReportNamedInstances/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: ReportNamedInstanceModel) : Promise<ReportNamedInstanceModel> {
        const localVarPath = this.basePath + '/ReportNamedInstance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ReportNamedInstanceModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ReportNamedInstanceModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ReportNamedInstanceModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param IDProject ID of record
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    public getReportNamedInstanceByProject (IDProject: number, Begin: number, Cap: number) : Promise<any> {
        const localVarPath = this.basePath + '/ReportNamedInstancesByProject/{IDProject}/{Begin}/{Cap}'
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)))
            .replace('{' + 'Begin' + '}', encodeURIComponent(String(Begin)))
            .replace('{' + 'Cap' + '}', encodeURIComponent(String(Cap)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling getReportNamedInstanceByProject.');
        }

        // verify required parameter 'Begin' is not null or undefined
        if (Begin === null || Begin === undefined) {
            throw new Error('Required parameter Begin was null or undefined when calling getReportNamedInstanceByProject.');
        }

        // verify required parameter 'Cap' is not null or undefined
        if (Cap === null || Cap === undefined) {
            throw new Error('Required parameter Cap was null or undefined when calling getReportNamedInstanceByProject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getReportNamedInstanceByProject!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/ReportNamedInstance/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<ReportNamedInstanceModel>> {
        const localVarPath = this.basePath + '/ReportNamedInstance/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ReportNamedInstanceModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ReportNamedInstanceModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<ReportNamedInstanceModel> {
        const localVarPath = this.basePath + '/ReportNamedInstance/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ReportNamedInstanceModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ReportNamedInstanceModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<ReportNamedInstanceModel>> {
        const localVarPath = this.basePath + '/ReportNamedInstances/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ReportNamedInstanceModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ReportNamedInstanceModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<ReportNamedInstanceModel>> {
        const localVarPath = this.basePath + '/ReportNamedInstances/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<ReportNamedInstanceModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<ReportNamedInstanceModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param IDProject ID of record
     * @param IDReportNamedInstance ID of record
     */
    public removeReportNamedInstanceFromProject (IDProject: number, IDReportNamedInstance: number) : Promise<any> {
        const localVarPath = this.basePath + '/ReportNamedInstance/{IDReportNamedInstance}/RemoveFromProject/{IDProject}'
            .replace('{' + 'IDProject' + '}', encodeURIComponent(String(IDProject)))
            .replace('{' + 'IDReportNamedInstance' + '}', encodeURIComponent(String(IDReportNamedInstance)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'IDProject' is not null or undefined
        if (IDProject === null || IDProject === undefined) {
            throw new Error('Required parameter IDProject was null or undefined when calling removeReportNamedInstanceFromProject.');
        }

        // verify required parameter 'IDReportNamedInstance' is not null or undefined
        if (IDReportNamedInstance === null || IDReportNamedInstance === undefined) {
            throw new Error('Required parameter IDReportNamedInstance was null or undefined when calling removeReportNamedInstanceFromProject.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in removeReportNamedInstanceFromProject!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: ReportNamedInstanceModel) : Promise<ReportNamedInstanceModel> {
        const localVarPath = this.basePath + '/ReportNamedInstance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ReportNamedInstanceModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<ReportNamedInstanceModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ReportNamedInstanceModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum SampleApiApiKeys {
}

export class SampleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SampleApiApiKeys, value: string) {
        (this.authentications as any)[SampleApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Sample/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Samples/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Samples/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: Sample) : Promise<Sample> {
        const localVarPath = this.basePath + '/Sample';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Sample")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Sample>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Sample");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Sample/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<Sample>> {
        const localVarPath = this.basePath + '/Sample/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Sample>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Sample>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<Sample> {
        const localVarPath = this.basePath + '/Sample/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Sample>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Sample");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<Sample>> {
        const localVarPath = this.basePath + '/Samples/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Sample>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Sample>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<Sample>> {
        const localVarPath = this.basePath + '/Samples/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Sample>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Sample>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: Sample) : Promise<Sample> {
        const localVarPath = this.basePath + '/Sample';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Sample")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Sample>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Sample");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum SampleLabJoinApiApiKeys {
}

export class SampleLabJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SampleLabJoinApiApiKeys, value: string) {
        (this.authentications as any)[SampleLabJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/SampleLabJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/SampleLabJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/SampleLabJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: SampleLabJoin) : Promise<SampleLabJoin> {
        const localVarPath = this.basePath + '/SampleLabJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SampleLabJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<SampleLabJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SampleLabJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/SampleLabJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<SampleLabJoin>> {
        const localVarPath = this.basePath + '/SampleLabJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<SampleLabJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<SampleLabJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<SampleLabJoin> {
        const localVarPath = this.basePath + '/SampleLabJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<SampleLabJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SampleLabJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<SampleLabJoin>> {
        const localVarPath = this.basePath + '/SampleLabJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<SampleLabJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<SampleLabJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<SampleLabJoin>> {
        const localVarPath = this.basePath + '/SampleLabJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<SampleLabJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<SampleLabJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: SampleLabJoin) : Promise<SampleLabJoin> {
        const localVarPath = this.basePath + '/SampleLabJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SampleLabJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<SampleLabJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SampleLabJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum SampleLineItemJoinApiApiKeys {
}

export class SampleLineItemJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SampleLineItemJoinApiApiKeys, value: string) {
        (this.authentications as any)[SampleLineItemJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/SampleLineItemJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/SampleLineItemJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/SampleLineItemJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: SampleLineItemJoin) : Promise<SampleLineItemJoin> {
        const localVarPath = this.basePath + '/SampleLineItemJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SampleLineItemJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<SampleLineItemJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SampleLineItemJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/SampleLineItemJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<SampleLineItemJoin>> {
        const localVarPath = this.basePath + '/SampleLineItemJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<SampleLineItemJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<SampleLineItemJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<SampleLineItemJoin> {
        const localVarPath = this.basePath + '/SampleLineItemJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<SampleLineItemJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SampleLineItemJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<SampleLineItemJoin>> {
        const localVarPath = this.basePath + '/SampleLineItemJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<SampleLineItemJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<SampleLineItemJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<SampleLineItemJoin>> {
        const localVarPath = this.basePath + '/SampleLineItemJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<SampleLineItemJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<SampleLineItemJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: SampleLineItemJoin) : Promise<SampleLineItemJoin> {
        const localVarPath = this.basePath + '/SampleLineItemJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SampleLineItemJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<SampleLineItemJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SampleLineItemJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum SampleLogApiApiKeys {
}

export class SampleLogApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SampleLogApiApiKeys, value: string) {
        (this.authentications as any)[SampleLogApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/SampleLog/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/SampleLogs/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/SampleLogs/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: SampleLog) : Promise<SampleLog> {
        const localVarPath = this.basePath + '/SampleLog';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SampleLog")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<SampleLog>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SampleLog");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/SampleLog/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<SampleLog>> {
        const localVarPath = this.basePath + '/SampleLog/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<SampleLog>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<SampleLog>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<SampleLog> {
        const localVarPath = this.basePath + '/SampleLog/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<SampleLog>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SampleLog");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<SampleLog>> {
        const localVarPath = this.basePath + '/SampleLogs/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<SampleLog>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<SampleLog>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<SampleLog>> {
        const localVarPath = this.basePath + '/SampleLogs/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<SampleLog>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<SampleLog>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: SampleLog) : Promise<SampleLog> {
        const localVarPath = this.basePath + '/SampleLog';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SampleLog")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<SampleLog>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SampleLog");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestApiApiKeys {
}

export class TestApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestApiApiKeys, value: string) {
        (this.authentications as any)[TestApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/Test/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Tests/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Tests/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: Test) : Promise<Test> {
        const localVarPath = this.basePath + '/Test';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Test")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Test>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Test");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Test/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<Test>> {
        const localVarPath = this.basePath + '/Test/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Test>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Test>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<Test> {
        const localVarPath = this.basePath + '/Test/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Test>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Test");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<Test>> {
        const localVarPath = this.basePath + '/Tests/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Test>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Test>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<Test>> {
        const localVarPath = this.basePath + '/Tests/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<Test>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<Test>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: Test) : Promise<Test> {
        const localVarPath = this.basePath + '/Test';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Test")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Test>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Test");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestDataApiApiKeys {
}

export class TestDataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestDataApiApiKeys, value: string) {
        (this.authentications as any)[TestDataApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestData/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestDatas/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestDatas/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestData) : Promise<TestData> {
        const localVarPath = this.basePath + '/TestData';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestData")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestData>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestData");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestData/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestData>> {
        const localVarPath = this.basePath + '/TestData/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestData>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestData>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestData> {
        const localVarPath = this.basePath + '/TestData/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestData>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestData");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestData>> {
        const localVarPath = this.basePath + '/TestDatas/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestData>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestData>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestData>> {
        const localVarPath = this.basePath + '/TestDatas/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestData>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestData>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestData) : Promise<TestData> {
        const localVarPath = this.basePath + '/TestData';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestData")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestData>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestData");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestInstanceApiApiKeys {
}

export class TestInstanceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestInstanceApiApiKeys, value: string) {
        (this.authentications as any)[TestInstanceApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestInstance/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstances/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstances/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestInstance) : Promise<TestInstance> {
        const localVarPath = this.basePath + '/TestInstance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestInstance")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstance>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstance");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstance/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestInstance>> {
        const localVarPath = this.basePath + '/TestInstance/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstance>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstance>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestInstance> {
        const localVarPath = this.basePath + '/TestInstance/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstance>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstance");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestInstance>> {
        const localVarPath = this.basePath + '/TestInstances/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstance>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstance>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestInstance>> {
        const localVarPath = this.basePath + '/TestInstances/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstance>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstance>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestInstance) : Promise<TestInstance> {
        const localVarPath = this.basePath + '/TestInstance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestInstance")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstance>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstance");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestInstanceDataApiApiKeys {
}

export class TestInstanceDataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestInstanceDataApiApiKeys, value: string) {
        (this.authentications as any)[TestInstanceDataApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestInstanceData/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceDatas/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceDatas/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestInstanceData) : Promise<TestInstanceData> {
        const localVarPath = this.basePath + '/TestInstanceData';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestInstanceData")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceData>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceData");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceData/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestInstanceData>> {
        const localVarPath = this.basePath + '/TestInstanceData/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceData>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceData>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestInstanceData> {
        const localVarPath = this.basePath + '/TestInstanceData/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceData>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceData");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestInstanceData>> {
        const localVarPath = this.basePath + '/TestInstanceDatas/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceData>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceData>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestInstanceData>> {
        const localVarPath = this.basePath + '/TestInstanceDatas/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceData>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceData>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestInstanceData) : Promise<TestInstanceData> {
        const localVarPath = this.basePath + '/TestInstanceData';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestInstanceData")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceData>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceData");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestInstanceDataArchiveApiApiKeys {
}

export class TestInstanceDataArchiveApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestInstanceDataArchiveApiApiKeys, value: string) {
        (this.authentications as any)[TestInstanceDataArchiveApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestInstanceDataArchive/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceDataArchives/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceDataArchives/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestInstanceDataArchive) : Promise<TestInstanceDataArchive> {
        const localVarPath = this.basePath + '/TestInstanceDataArchive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestInstanceDataArchive")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceDataArchive>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceDataArchive");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceDataArchive/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestInstanceDataArchive>> {
        const localVarPath = this.basePath + '/TestInstanceDataArchive/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceDataArchive>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceDataArchive>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestInstanceDataArchive> {
        const localVarPath = this.basePath + '/TestInstanceDataArchive/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceDataArchive>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceDataArchive");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestInstanceDataArchive>> {
        const localVarPath = this.basePath + '/TestInstanceDataArchives/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceDataArchive>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceDataArchive>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestInstanceDataArchive>> {
        const localVarPath = this.basePath + '/TestInstanceDataArchives/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceDataArchive>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceDataArchive>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestInstanceDataArchive) : Promise<TestInstanceDataArchive> {
        const localVarPath = this.basePath + '/TestInstanceDataArchive';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestInstanceDataArchive")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceDataArchive>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceDataArchive");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestInstanceLabJoinApiApiKeys {
}

export class TestInstanceLabJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestInstanceLabJoinApiApiKeys, value: string) {
        (this.authentications as any)[TestInstanceLabJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestInstanceLabJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceLabJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceLabJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestInstanceLabJoin) : Promise<TestInstanceLabJoin> {
        const localVarPath = this.basePath + '/TestInstanceLabJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestInstanceLabJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceLabJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceLabJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceLabJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestInstanceLabJoin>> {
        const localVarPath = this.basePath + '/TestInstanceLabJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceLabJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceLabJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestInstanceLabJoin> {
        const localVarPath = this.basePath + '/TestInstanceLabJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceLabJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceLabJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestInstanceLabJoin>> {
        const localVarPath = this.basePath + '/TestInstanceLabJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceLabJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceLabJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestInstanceLabJoin>> {
        const localVarPath = this.basePath + '/TestInstanceLabJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceLabJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceLabJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestInstanceLabJoin) : Promise<TestInstanceLabJoin> {
        const localVarPath = this.basePath + '/TestInstanceLabJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestInstanceLabJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceLabJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceLabJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestInstanceSampleJoinApiApiKeys {
}

export class TestInstanceSampleJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestInstanceSampleJoinApiApiKeys, value: string) {
        (this.authentications as any)[TestInstanceSampleJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestInstanceSampleJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceSampleJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceSampleJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestInstanceSampleJoin) : Promise<TestInstanceSampleJoin> {
        const localVarPath = this.basePath + '/TestInstanceSampleJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestInstanceSampleJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceSampleJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceSampleJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestInstanceSampleJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestInstanceSampleJoin>> {
        const localVarPath = this.basePath + '/TestInstanceSampleJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceSampleJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceSampleJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestInstanceSampleJoin> {
        const localVarPath = this.basePath + '/TestInstanceSampleJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceSampleJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceSampleJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestInstanceSampleJoin>> {
        const localVarPath = this.basePath + '/TestInstanceSampleJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceSampleJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceSampleJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestInstanceSampleJoin>> {
        const localVarPath = this.basePath + '/TestInstanceSampleJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestInstanceSampleJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestInstanceSampleJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestInstanceSampleJoin) : Promise<TestInstanceSampleJoin> {
        const localVarPath = this.basePath + '/TestInstanceSampleJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestInstanceSampleJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestInstanceSampleJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestInstanceSampleJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestLabJoinApiApiKeys {
}

export class TestLabJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestLabJoinApiApiKeys, value: string) {
        (this.authentications as any)[TestLabJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestLabJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestLabJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestLabJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestLabJoin) : Promise<TestLabJoin> {
        const localVarPath = this.basePath + '/TestLabJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestLabJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestLabJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestLabJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestLabJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestLabJoin>> {
        const localVarPath = this.basePath + '/TestLabJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestLabJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestLabJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestLabJoin> {
        const localVarPath = this.basePath + '/TestLabJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestLabJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestLabJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestLabJoin>> {
        const localVarPath = this.basePath + '/TestLabJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestLabJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestLabJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestLabJoin>> {
        const localVarPath = this.basePath + '/TestLabJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestLabJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestLabJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestLabJoin) : Promise<TestLabJoin> {
        const localVarPath = this.basePath + '/TestLabJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestLabJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestLabJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestLabJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestPlanApiApiKeys {
}

export class TestPlanApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestPlanApiApiKeys, value: string) {
        (this.authentications as any)[TestPlanApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestPlan/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestPlans/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestPlans/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestPlan) : Promise<TestPlan> {
        const localVarPath = this.basePath + '/TestPlan';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestPlan")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestPlan>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestPlan");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestPlan/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestPlan>> {
        const localVarPath = this.basePath + '/TestPlan/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestPlan>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestPlan>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestPlan> {
        const localVarPath = this.basePath + '/TestPlan/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestPlan>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestPlan");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestPlan>> {
        const localVarPath = this.basePath + '/TestPlans/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestPlan>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestPlan>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestPlan>> {
        const localVarPath = this.basePath + '/TestPlans/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestPlan>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestPlan>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestPlan) : Promise<TestPlan> {
        const localVarPath = this.basePath + '/TestPlan';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestPlan")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestPlan>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestPlan");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestRecordOfMaterialEntryJoinApiApiKeys {
}

export class TestRecordOfMaterialEntryJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestRecordOfMaterialEntryJoinApiApiKeys, value: string) {
        (this.authentications as any)[TestRecordOfMaterialEntryJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestRecordOfMaterialEntryJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestRecordOfMaterialEntryJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestRecordOfMaterialEntryJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestRecordOfMaterialEntryJoin) : Promise<TestRecordOfMaterialEntryJoin> {
        const localVarPath = this.basePath + '/TestRecordOfMaterialEntryJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestRecordOfMaterialEntryJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestRecordOfMaterialEntryJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestRecordOfMaterialEntryJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestRecordOfMaterialEntryJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestRecordOfMaterialEntryJoin>> {
        const localVarPath = this.basePath + '/TestRecordOfMaterialEntryJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestRecordOfMaterialEntryJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestRecordOfMaterialEntryJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestRecordOfMaterialEntryJoin> {
        const localVarPath = this.basePath + '/TestRecordOfMaterialEntryJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestRecordOfMaterialEntryJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestRecordOfMaterialEntryJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestRecordOfMaterialEntryJoin>> {
        const localVarPath = this.basePath + '/TestRecordOfMaterialEntryJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestRecordOfMaterialEntryJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestRecordOfMaterialEntryJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestRecordOfMaterialEntryJoin>> {
        const localVarPath = this.basePath + '/TestRecordOfMaterialEntryJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestRecordOfMaterialEntryJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestRecordOfMaterialEntryJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestRecordOfMaterialEntryJoin) : Promise<TestRecordOfMaterialEntryJoin> {
        const localVarPath = this.basePath + '/TestRecordOfMaterialEntryJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestRecordOfMaterialEntryJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestRecordOfMaterialEntryJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestRecordOfMaterialEntryJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestSpecificationApiApiKeys {
}

export class TestSpecificationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestSpecificationApiApiKeys, value: string) {
        (this.authentications as any)[TestSpecificationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestSpecification/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecifications/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecifications/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestSpecification) : Promise<TestSpecification> {
        const localVarPath = this.basePath + '/TestSpecification';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestSpecification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecification>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecification");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecification/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestSpecification>> {
        const localVarPath = this.basePath + '/TestSpecification/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecification>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecification>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestSpecification> {
        const localVarPath = this.basePath + '/TestSpecification/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecification>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecification");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestSpecification>> {
        const localVarPath = this.basePath + '/TestSpecifications/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecification>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecification>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestSpecification>> {
        const localVarPath = this.basePath + '/TestSpecifications/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecification>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecification>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestSpecification) : Promise<TestSpecification> {
        const localVarPath = this.basePath + '/TestSpecification';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestSpecification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecification>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecification");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestSpecificationMaterialTestJoinApiApiKeys {
}

export class TestSpecificationMaterialTestJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestSpecificationMaterialTestJoinApiApiKeys, value: string) {
        (this.authentications as any)[TestSpecificationMaterialTestJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestSpecificationMaterialTestJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationMaterialTestJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationMaterialTestJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestSpecificationMaterialTestJoin) : Promise<TestSpecificationMaterialTestJoin> {
        const localVarPath = this.basePath + '/TestSpecificationMaterialTestJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestSpecificationMaterialTestJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationMaterialTestJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationMaterialTestJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationMaterialTestJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestSpecificationMaterialTestJoin>> {
        const localVarPath = this.basePath + '/TestSpecificationMaterialTestJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationMaterialTestJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationMaterialTestJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestSpecificationMaterialTestJoin> {
        const localVarPath = this.basePath + '/TestSpecificationMaterialTestJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationMaterialTestJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationMaterialTestJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestSpecificationMaterialTestJoin>> {
        const localVarPath = this.basePath + '/TestSpecificationMaterialTestJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationMaterialTestJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationMaterialTestJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestSpecificationMaterialTestJoin>> {
        const localVarPath = this.basePath + '/TestSpecificationMaterialTestJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationMaterialTestJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationMaterialTestJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestSpecificationMaterialTestJoin) : Promise<TestSpecificationMaterialTestJoin> {
        const localVarPath = this.basePath + '/TestSpecificationMaterialTestJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestSpecificationMaterialTestJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationMaterialTestJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationMaterialTestJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestSpecificationRequirementApiApiKeys {
}

export class TestSpecificationRequirementApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestSpecificationRequirementApiApiKeys, value: string) {
        (this.authentications as any)[TestSpecificationRequirementApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestSpecificationRequirement/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationRequirements/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationRequirements/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestSpecificationRequirement) : Promise<TestSpecificationRequirement> {
        const localVarPath = this.basePath + '/TestSpecificationRequirement';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestSpecificationRequirement")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationRequirement>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationRequirement");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationRequirement/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestSpecificationRequirement>> {
        const localVarPath = this.basePath + '/TestSpecificationRequirement/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationRequirement>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationRequirement>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestSpecificationRequirement> {
        const localVarPath = this.basePath + '/TestSpecificationRequirement/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationRequirement>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationRequirement");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestSpecificationRequirement>> {
        const localVarPath = this.basePath + '/TestSpecificationRequirements/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationRequirement>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationRequirement>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestSpecificationRequirement>> {
        const localVarPath = this.basePath + '/TestSpecificationRequirements/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationRequirement>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationRequirement>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestSpecificationRequirement) : Promise<TestSpecificationRequirement> {
        const localVarPath = this.basePath + '/TestSpecificationRequirement';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestSpecificationRequirement")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationRequirement>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationRequirement");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestSpecificationSetApiApiKeys {
}

export class TestSpecificationSetApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestSpecificationSetApiApiKeys, value: string) {
        (this.authentications as any)[TestSpecificationSetApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestSpecificationSet/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationSets/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationSets/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestSpecificationSet) : Promise<TestSpecificationSet> {
        const localVarPath = this.basePath + '/TestSpecificationSet';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestSpecificationSet")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationSet>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationSet");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationSet/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestSpecificationSet>> {
        const localVarPath = this.basePath + '/TestSpecificationSet/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationSet>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationSet>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestSpecificationSet> {
        const localVarPath = this.basePath + '/TestSpecificationSet/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationSet>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationSet");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestSpecificationSet>> {
        const localVarPath = this.basePath + '/TestSpecificationSets/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationSet>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationSet>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestSpecificationSet>> {
        const localVarPath = this.basePath + '/TestSpecificationSets/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationSet>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationSet>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestSpecificationSet) : Promise<TestSpecificationSet> {
        const localVarPath = this.basePath + '/TestSpecificationSet';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestSpecificationSet")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationSet>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationSet");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestSpecificationSetTestJoinApiApiKeys {
}

export class TestSpecificationSetTestJoinApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestSpecificationSetTestJoinApiApiKeys, value: string) {
        (this.authentications as any)[TestSpecificationSetTestJoinApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestSpecificationSetTestJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationSetTestJoins/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationSetTestJoins/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestSpecificationSetTestJoin) : Promise<TestSpecificationSetTestJoin> {
        const localVarPath = this.basePath + '/TestSpecificationSetTestJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestSpecificationSetTestJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationSetTestJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationSetTestJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSpecificationSetTestJoin/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestSpecificationSetTestJoin>> {
        const localVarPath = this.basePath + '/TestSpecificationSetTestJoin/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationSetTestJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationSetTestJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestSpecificationSetTestJoin> {
        const localVarPath = this.basePath + '/TestSpecificationSetTestJoin/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationSetTestJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationSetTestJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestSpecificationSetTestJoin>> {
        const localVarPath = this.basePath + '/TestSpecificationSetTestJoins/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationSetTestJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationSetTestJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestSpecificationSetTestJoin>> {
        const localVarPath = this.basePath + '/TestSpecificationSetTestJoins/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestSpecificationSetTestJoin>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestSpecificationSetTestJoin>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestSpecificationSetTestJoin) : Promise<TestSpecificationSetTestJoin> {
        const localVarPath = this.basePath + '/TestSpecificationSetTestJoin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestSpecificationSetTestJoin")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestSpecificationSetTestJoin>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestSpecificationSetTestJoin");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum TestStepApiApiKeys {
}

export class TestStepApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TestStepApiApiKeys, value: string) {
        (this.authentications as any)[TestStepApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/TestStep/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSteps/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestSteps/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: TestStep) : Promise<TestStep> {
        const localVarPath = this.basePath + '/TestStep';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestStep")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestStep>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestStep");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/TestStep/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<TestStep>> {
        const localVarPath = this.basePath + '/TestStep/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestStep>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestStep>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<TestStep> {
        const localVarPath = this.basePath + '/TestStep/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestStep>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestStep");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<TestStep>> {
        const localVarPath = this.basePath + '/TestSteps/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestStep>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestStep>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<TestStep>> {
        const localVarPath = this.basePath + '/TestSteps/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<TestStep>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<TestStep>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: TestStep) : Promise<TestStep> {
        const localVarPath = this.basePath + '/TestStep';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TestStep")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<TestStep>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TestStep");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
export enum UserApiApiKeys {
}

export class UserApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected _lastResponse : any = null;
    protected _timeout: number = DEFAULT_TIMEOUT;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set timeout(pTimeout: number) {
        this._timeout = pTimeout;
    }

    get timeout() {
        return this._timeout;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
    }
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    public _delete (id: number) : Promise<boolean> {
        const localVarPath = this.basePath + '/User/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<boolean>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "boolean");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in _delete!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Check if an email is already in use
     * @param Email 
     */
    public checkEmail (Email: string) : Promise<any> {
        const localVarPath = this.basePath + '/User/CheckEmail/{Email}'
            .replace('{' + 'Email' + '}', encodeURIComponent(String(Email)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'Email' is not null or undefined
        if (Email === null || Email === undefined) {
            throw new Error('Required parameter Email was null or undefined when calling checkEmail.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in checkEmail!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Check if a LoginID is already in use
     * @param LoginID 
     */
    public checkLoginID (LoginID: string) : Promise<any> {
        const localVarPath = this.basePath + '/User/CheckLoginID/{LoginID}'
            .replace('{' + 'LoginID' + '}', encodeURIComponent(String(LoginID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'LoginID' is not null or undefined
        if (LoginID === null || LoginID === undefined) {
            throw new Error('Required parameter LoginID was null or undefined when calling checkLoginID.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in checkLoginID!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Email confirmation link for self-signup user
     * @param EmailConfirmHash Hash code sent in confirmation email
     */
    public confirmEmail (EmailConfirmHash: string) : Promise<any> {
        const localVarPath = this.basePath + '/User/ConfirmEmail/{EmailConfirmHash}'
            .replace('{' + 'EmailConfirmHash' + '}', encodeURIComponent(String(EmailConfirmHash)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'EmailConfirmHash' is not null or undefined
        if (EmailConfirmHash === null || EmailConfirmHash === undefined) {
            throw new Error('Required parameter EmailConfirmHash was null or undefined when calling confirmEmail.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in confirmEmail!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT
     */
    public count () : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Users/Count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in count!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    public countFiltered (filter: string) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/Users/FilteredTo/{filter}/Count'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling countFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in countFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow POST (Create)
     * @param body 
     */
    public create (body: UserModel) : Promise<UserModel> {
        const localVarPath = this.basePath + '/User';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<UserModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UserModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in create!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * User forgot password email with link
     * @param Email 
     */
    public forgotPassword (Email: string) : Promise<any> {
        const localVarPath = this.basePath + '/User/ForgotPassword/{Email}'
            .replace('{' + 'Email' + '}', encodeURIComponent(String(Email)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'Email' is not null or undefined
        if (Email === null || Email === undefined) {
            throw new Error('Required parameter Email was null or undefined when calling forgotPassword.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in forgotPassword!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Get Avtive Users list 
     */
    public getActiveUsers () : Promise<any> {
        const localVarPath = this.basePath + '/User/Active';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getActiveUsers!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Send version and last update dates for various 
     */
    public getSyncIndicator () : Promise<any> {
        const localVarPath = this.basePath + '/User/SyncIndicator';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in getSyncIndicator!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadCountQuery (body: QueryRequest) : Promise<InlineResponse200> {
        const localVarPath = this.basePath + '/User/query/count';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadCountQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<InlineResponse200>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "InlineResponse200");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadCountQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * 
     * @param body 
     */
    public postReadQuery (body: QueryRequest) : Promise<Array<UserModel>> {
        const localVarPath = this.basePath + '/User/query/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postReadQuery.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "QueryRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<UserModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<UserModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in postReadQuery!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ
     * @param id ID of record
     */
    public read (id: number) : Promise<UserModel> {
        const localVarPath = this.basePath + '/User/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling read.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<UserModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UserModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in read!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public reads (begin: number, max: number) : Promise<Array<UserModel>> {
        const localVarPath = this.basePath + '/Users/{begin}/{max}'
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling reads.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling reads.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<UserModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<UserModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in reads!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    public readsFiltered (filter: string, begin: number, max: number) : Promise<Array<UserModel>> {
        const localVarPath = this.basePath + '/Users/FilteredTo/{filter}/{begin}/{max}'
            .replace('{' + 'filter' + '}', encodeURIComponent(String(filter)))
            .replace('{' + 'begin' + '}', encodeURIComponent(String(begin)))
            .replace('{' + 'max' + '}', encodeURIComponent(String(max)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'begin' is not null or undefined
        if (begin === null || begin === undefined) {
            throw new Error('Required parameter begin was null or undefined when calling readsFiltered.');
        }

        // verify required parameter 'max' is not null or undefined
        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling readsFiltered.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<Array<UserModel>>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Array<UserModel>");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in readsFiltered!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Request to resend confirmation email (user email must not be confirmed yet)
     * @param Email 
     */
    public resendConfirmationEmail (Email: string) : Promise<any> {
        const localVarPath = this.basePath + '/User/ResendConfirmationEmail/{Email}'
            .replace('{' + 'Email' + '}', encodeURIComponent(String(Email)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'Email' is not null or undefined
        if (Email === null || Email === undefined) {
            throw new Error('Required parameter Email was null or undefined when calling resendConfirmationEmail.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in resendConfirmationEmail!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * User self-signup
     * @param body 
     */
    public signupUser (body: UserSignupRequest) : Promise<any> {
        const localVarPath = this.basePath + '/User/Signup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling signupUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserSignupRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in signupUser!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Meadow PUT (Update)
     * @param body 
     */
    public update (body: UserModel) : Promise<UserModel> {
        const localVarPath = this.basePath + '/User';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserModel")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<UserModel>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UserModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in update!`);
                        }
                    }
                })
            })
        );
    }
    /**
     * Change user password *
     * @param body 
     */
    public updatePassword (body: ChangePasswordRequest) : Promise<any> {
        const localVarPath = this.basePath + '/Password';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        //clear last response before initiating next operation
        this._lastResponse = null;

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePassword.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            timeout: this._timeout,
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ChangePasswordRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return this.authentications.default.executeWithAuth(localVarRequestOptions, ()=>
            new Promise<any>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    this._lastResponse = response;

                    if (error || (body && body.Error)) {
                        reject(error || body.Error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve(body);
                        } else {
                            reject(`Request Error ${response.statusCode} in updatePassword!`);
                        }
                    }
                })
            })
        );
    }

    public getLastResponse() : any
    {
        let response = this._lastResponse;
        this._lastResponse = null;

        return response;
    }
}
