/// <reference types="request" />
/// <reference types="node" />
/**
 * HeadlightAPI
 * Pavia Headlight API Server
 *
 * OpenAPI spec version: 0.0.12
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import localVarRequest = require('request');
/**
*
*/
export declare class Artifact {
    /**
    *
    */
    'IDArtifact': number;
    /**
    *
    */
    'GUIDArtifact': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ArtifactType': string;
    /**
    *
    */
    'Datum': string;
    /**
    *
    */
    'Version': number;
    /**
    *
    */
    'Invalid': number;
    /**
    *
    */
    'IDDevice': number;
    /**
    *
    */
    'Sync': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ArtifactModel {
    /**
    *
    */
    'Datum': any;
    /**
    *
    */
    'FileName': any;
    /**
    *
    */
    'IDObservationRequirementSpecification': any;
    /**
    *
    */
    'IDArtifact': number;
    /**
    *
    */
    'GUIDArtifact': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ArtifactType': string;
    /**
    *
    */
    'Version': number;
    /**
    *
    */
    'Invalid': number;
    /**
    *
    */
    'IDDevice': number;
    /**
    *
    */
    'Sync': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class BidItem {
    /**
    *
    */
    'IDBidItem': number;
    /**
    *
    */
    'GUIDBidItem': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'IDContract': number;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDPayItem': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ChangePasswordRequest {
    /**
    *
    */
    'NewPassword': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class CommentModel {
    /**
    *
    */
    'Metadata': any;
    /**
    *
    */
    'IDComment': number;
    /**
    *
    */
    'GUIDComment': string;
    /**
    *
    */
    'IDParent': number;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Comment': string;
    /**
    *
    */
    'CommentHtml': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class Contract {
    /**
    *
    */
    'IDContract': number;
    /**
    *
    */
    'GUIDContract': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'IDOrganization': number;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'PrimaryProjectNumber': string;
    /**
    *
    */
    'CountyProjectNumber': string;
    /**
    *
    */
    'StateProjectNumber': string;
    /**
    *
    */
    'FederalProjectNumber': string;
    /**
    *
    */
    'Status': string;
    /**
    *
    */
    'DBEStructure': string;
    /**
    *
    */
    'RouteNumber': string;
    /**
    *
    */
    'HighwayNumber': string;
    /**
    *
    */
    'PavingMaterial': string;
    /**
    *
    */
    'StationBegin': string;
    /**
    *
    */
    'TerminusBegin': string;
    /**
    *
    */
    'TerminusEnd': string;
    /**
    *
    */
    'StationEnd': string;
    /**
    *
    */
    'TotalBidAmount': string;
    /**
    *
    */
    'NetChangeOrderAmount': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class Customer {
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'GUIDCustomer': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Code': string;
    /**
    *
    */
    'Enabled': number;
    /**
    *
    */
    'CustomProperties': string;
    /**
    *
    */
    'Timezone': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class DocumentModel {
    /**
    *
    */
    'Observations': Array<number>;
    /**
    *
    */
    'Comments': Array<number>;
    /**
    *
    */
    'ElectronicSignatures': Array<ElectronicSignature>;
    /**
    *
    */
    'FormData': any;
    /**
    *
    */
    'IDDocument': number;
    /**
    *
    */
    'GUIDDocument': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'DocumentType': string;
    /**
    *
    */
    'DocumentDate': Date;
    /**
    *
    */
    'Status': string;
    /**
    *
    */
    'Version': number;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'IDDevice': number;
    /**
    *
    */
    'AppHash': string;
    /**
    *
    */
    'Timezone': string;
    /**
    *
    */
    'Shift': string;
    /**
    *
    */
    'StateName': string;
    /**
    *
    */
    'StateStep': number;
    /**
    *
    */
    'Locked': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'SequenceNumber': number;
    /**
    *
    */
    'ExternalSyncGUID': string;
    /**
    *
    */
    'Form': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class DocumentStateChangeRequest {
    /**
    *
    */
    'IDDocument': number;
    /**
    *
    */
    'Action': string;
    /**
    *
    */
    'IDElectronicSignature': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ElectronicSignature {
    /**
    *
    */
    'IDElectronicSignature': number;
    /**
    *
    */
    'GUIDElectronicSignature': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Signer': string;
    /**
    *
    */
    'IDContact': number;
    /**
    *
    */
    'SignatureType': string;
    /**
    *
    */
    'IDArtifact': number;
    /**
    *
    */
    'Approved': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ElectronicSignatureModel {
    /**
    *
    */
    'Comments': Array<number>;
    /**
    *
    */
    'IDElectronicSignature': number;
    /**
    *
    */
    'GUIDElectronicSignature': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Signer': string;
    /**
    *
    */
    'IDContact': number;
    /**
    *
    */
    'SignatureType': string;
    /**
    *
    */
    'IDArtifact': number;
    /**
    *
    */
    'Approved': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class Equipment {
    /**
    *
    */
    'IDEquipment': number;
    /**
    *
    */
    'GUIDEquipment': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'Notes': string;
    /**
    *
    */
    'SpecificationYear': number;
    /**
    *
    */
    'Code': string;
    /**
    *
    */
    'Status': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class FormProcessorRequest {
    /**
    *
    */
    'IDDocument': number;
    /**
    *
    */
    'Observations': Array<ObservationModel>;
    /**
    *
    */
    'Samples': Array<Sample>;
    /**
    *
    */
    'SampleLogs': Array<SampleLog>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ISession {
    /**
    *
    */
    'SessionID': string;
    /**
    *
    */
    'LoggedIn': boolean;
    /**
    *
    */
    'UserRole': string;
    /**
    *
    */
    'UserRoleIndex': number;
    /**
    *
    */
    'UserID': number;
    /**
    *
    */
    'CustomerID': number;
    /**
    *
    */
    'Title': string;
    /**
    *
    */
    'NameFirst': string;
    /**
    *
    */
    'NameLast': string;
    /**
    *
    */
    'Email': string;
    /**
    *
    */
    'LoginID': string;
    /**
    *
    */
    'UIHash': string;
    /**
    *
    */
    'Timezone': string;
    /**
    *
    */
    'Settings': any;
    /**
    *
    */
    'DeviceID': string;
    /**
    *
    */
    'IDDevice': number;
    /**
    *
    */
    'ServerHostURL': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class InlineResponse200 {
    /**
    *
    */
    'Count'?: number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class InlineResponse2001 {
    /**
    *
    */
    'Token'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export declare class InlineResponse2002 {
    /**
    *
    */
    'Success'?: boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class Lab {
    /**
    *
    */
    'IDLab': number;
    /**
    *
    */
    'GUIDLab': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'IDOrganization': number;
    /**
    *
    */
    'IDOrganizationAddress': number;
    /**
    *
    */
    'ExternalOrganization': number;
    /**
    *
    */
    'Notes': string;
    /**
    *
    */
    'IDLabParent': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class LabMaterialAssignment {
    /**
    *
    */
    'IDLabMaterialAssignment': number;
    /**
    *
    */
    'GUIDLabMaterialAssignment': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDLab': number;
    /**
    *
    */
    'IDLabParent': number;
    /**
    *
    */
    'IDMaterial': number;
    /**
    *
    */
    'SampleType': string;
    /**
    *
    */
    'ProductGroup': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class LabTestApproval {
    /**
    *
    */
    'IDLabTestApproval': number;
    /**
    *
    */
    'GUIDLabTestApproval': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDLab': number;
    /**
    *
    */
    'IDTest': number;
    /**
    *
    */
    'DateStart': Date;
    /**
    *
    */
    'DateEnd': Date;
    /**
    *
    */
    'Notes': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class LabTestDefault {
    /**
    *
    */
    'IDLabTestDefault': number;
    /**
    *
    */
    'GUIDLabTestDefault': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDLab': number;
    /**
    *
    */
    'IDMaterial': number;
    /**
    *
    */
    'IDTest': number;
    /**
    *
    */
    'SampleType': string;
    /**
    *
    */
    'StartStatus': number;
    /**
    *
    */
    'RequiredAssign': number;
    /**
    *
    */
    'Autofinalize': number;
    /**
    *
    */
    'DefinedTest': number;
    /**
    *
    */
    'TestRuns': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class LineItem {
    /**
    *
    */
    'IDLineItem': number;
    /**
    *
    */
    'GUIDLineItem': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'Units': string;
    /**
    *
    */
    'CostPerUnit': string;
    /**
    *
    */
    'ExpectedQuantity': string;
    /**
    *
    */
    'ActualQuantity': string;
    /**
    *
    */
    'PercentComplete': number;
    /**
    *
    */
    'IDBidItem': number;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'ContractQuantity': string;
    /**
    *
    */
    'InstalledQuantity': string;
    /**
    *
    */
    'Status': string;
    /**
    *
    */
    'ProposalIdentifier': string;
    /**
    *
    */
    'Notes': string;
    /**
    *
    */
    'SpecificationYear': number;
    /**
    *
    */
    'ItemCode': string;
    /**
    *
    */
    'ChangeOrderQuantity': string;
    /**
    *
    */
    'ChangeOrderQuantityPending': string;
    /**
    *
    */
    'ChangeOrderNumber': string;
    /**
    *
    */
    'FundingCategory': string;
    /**
    *
    */
    'CategoryNumber': string;
    /**
    *
    */
    'Tax': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class LoginRequest {
    /**
    *
    */
    'UserName': string;
    /**
    *
    */
    'Password': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class MappedArrayArtifact {
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class Material {
    /**
    *
    */
    'IDMaterial': number;
    /**
    *
    */
    'GUIDMaterial': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'NameAbbreviated': string;
    /**
    *
    */
    'Type': string;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'CatalogCode': string;
    /**
    *
    */
    'UnitsMetric': string;
    /**
    *
    */
    'UnitsImperial': string;
    /**
    *
    */
    'Active': number;
    /**
    *
    */
    'BrandNameRequired': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class MaterialLineItemJoin {
    /**
    *
    */
    'IDMaterialLineItemJoin': number;
    /**
    *
    */
    'GUIDMaterialLineItemJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDLineItem': number;
    /**
    *
    */
    'IDMaterial': number;
    /**
    *
    */
    'ConversionFactor': string;
    /**
    *
    */
    'ApprovedSourceRequired': number;
    /**
    *
    */
    'SpecialInstructions': string;
    /**
    *
    */
    'Units': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class MaterialPayItemJoin {
    /**
    *
    */
    'IDMaterialPayItemJoin': number;
    /**
    *
    */
    'GUIDMaterialPayItemJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Approved': number;
    /**
    *
    */
    'IDPayItem': number;
    /**
    *
    */
    'IDMaterial': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class MaterialRecordOfMaterialEntryJoin {
    /**
    *
    */
    'IDMaterialRecordOfMaterialEntryJoin': number;
    /**
    *
    */
    'GUIDMaterialRecordOfMaterialEntryJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDMaterial': number;
    /**
    *
    */
    'IDRecordOfMaterialEntry': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class MixSpecification {
    /**
    *
    */
    'IDMixSpecification': number;
    /**
    *
    */
    'GUIDMixSpecification': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'Code': string;
    /**
    *
    */
    'MaterialType': string;
    /**
    *
    */
    'EffectiveDate': Date;
    /**
    *
    */
    'ExpirationDate': Date;
    /**
    *
    */
    'ApprovalDate': Date;
    /**
    *
    */
    'ApprovingIDUser': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class MixSpecificationMaterialJoin {
    /**
    *
    */
    'IDMixSpecificationMaterialJoin': number;
    /**
    *
    */
    'GUIDMixSpecificationMaterialJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDMixSpecification': number;
    /**
    *
    */
    'IDMaterial': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ModuleModel {
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Settings': any;
    /**
    *
    */
    'Configuration': any;
    /**
    *
    */
    'IDModule': number;
    /**
    *
    */
    'GUIDModule': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Management': number;
    /**
    *
    */
    'ModuleHash': string;
    /**
    *
    */
    'Ordinal': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class Notification {
    /**
    *
    */
    'IDNotification': number;
    /**
    *
    */
    'GUIDNotification': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'IDNotificationRule': number;
    /**
    *
    */
    'RecipientIDUser': number;
    /**
    *
    */
    'NotificationMessage': string;
    /**
    *
    */
    'Unread': number;
    /**
    *
    */
    'NotificationType': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ObservationArchive {
    /**
    *
    */
    'IDObservationArchive': number;
    /**
    *
    */
    'GUIDObservationArchive': string;
    /**
    *
    */
    'IDObservation': number;
    /**
    *
    */
    'GUIDObservation': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'IDDevice': number;
    /**
    *
    */
    'CaptureLatitude': string;
    /**
    *
    */
    'CaptureLongitude': string;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'Priority': string;
    /**
    *
    */
    'Tags': string;
    /**
    *
    */
    'Contractors': string;
    /**
    *
    */
    'BidItems': string;
    /**
    *
    */
    'Version': number;
    /**
    *
    */
    'SpritePage': number;
    /**
    *
    */
    'DesignatedTime': Date;
    /**
    *
    */
    'ObservationType': string;
    /**
    *
    */
    'UserLatitude': string;
    /**
    *
    */
    'UserLongitude': string;
    /**
    *
    */
    'AlignmentStation': string;
    /**
    *
    */
    'AlignmentOffset': string;
    /**
    *
    */
    'SnapshotJSON': string;
    /**
    *
    */
    'AppHash': string;
    /**
    *
    */
    'Locked': number;
    /**
    *
    */
    'Transcoded': number;
    /**
    *
    */
    'Status': string;
    /**
    *
    */
    'StateName': string;
    /**
    *
    */
    'StateStep': number;
    /**
    *
    */
    'LineItems': string;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'Equipment': string;
    /**
    *
    */
    'ExternalSyncGUID': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ObservationCloneRequest {
    /**
    *
    */
    'IDObservations': Array<number>;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'OffsetFromSpecificTime': Date;
    /**
    *
    */
    'OffsetFromCurrentTime': Date;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ObservationFilterRequest {
    /**
    *
    */
    'SearchText': string;
    'Priority': ObservationFilterRequestPriority;
    /**
    *
    */
    'ObservationType': Array<string>;
    /**
    *
    */
    'Contractors': Array<string>;
    'DesignatedTime': ObservationFilterRequestDesignatedTime;
    /**
    *
    */
    'IDProject': number;
    'DocumentCount': ObservationFilterRequestPriority;
    /**
    *
    */
    'IDArtifact': Array<number>;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ObservationFilterRequestDesignatedTime {
    /**
    *
    */
    'From'?: Date;
    /**
    *
    */
    'To'?: Date;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ObservationFilterRequestPriority {
    /**
    *
    */
    'Compare'?: string;
    /**
    *
    */
    'Value'?: number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ObservationModel {
    'Labels': ObservationModelLabels;
    'Details': MappedArrayArtifact;
    /**
    *
    */
    'Statistics': any;
    /**
    *
    */
    'IDObservation': number;
    /**
    *
    */
    'GUIDObservation': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'IDDevice': number;
    /**
    *
    */
    'CaptureLatitude': string;
    /**
    *
    */
    'CaptureLongitude': string;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'Priority': string;
    /**
    *
    */
    'Version': number;
    /**
    *
    */
    'SpritePage': number;
    /**
    *
    */
    'DesignatedTime': Date;
    /**
    *
    */
    'ObservationType': string;
    /**
    *
    */
    'UserLatitude': string;
    /**
    *
    */
    'UserLongitude': string;
    /**
    *
    */
    'AlignmentStation': string;
    /**
    *
    */
    'AlignmentOffset': string;
    /**
    *
    */
    'AppHash': string;
    /**
    *
    */
    'Locked': number;
    /**
    *
    */
    'Transcoded': number;
    /**
    *
    */
    'Status': string;
    /**
    *
    */
    'StateName': string;
    /**
    *
    */
    'StateStep': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'ExternalSyncGUID': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ObservationModelLabels {
    /**
    *
    */
    'SAVE'?: boolean;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class Organization {
    /**
    *
    */
    'IDOrganization': number;
    /**
    *
    */
    'GUIDOrganization': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'DisadvantagedBusiness': number;
    /**
    *
    */
    'Address': string;
    /**
    *
    */
    'City': string;
    /**
    *
    */
    'State': string;
    /**
    *
    */
    'Zip': string;
    /**
    *
    */
    'Phone': string;
    /**
    *
    */
    'Approved': number;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'Email': string;
    /**
    *
    */
    'Type': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class OrganizationMaterialJoin {
    /**
    *
    */
    'IDOrganizationMaterialJoin': number;
    /**
    *
    */
    'GUIDOrganizationMaterialJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDOrganization': number;
    /**
    *
    */
    'IDMaterial': number;
    /**
    *
    */
    'EffectiveDate': Date;
    /**
    *
    */
    'ExpirationDate': Date;
    /**
    *
    */
    'ApprovedStatusType': string;
    /**
    *
    */
    'SourceType': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class PayItemModel {
    /**
    *
    */
    'Extended': any;
    /**
    *
    */
    'IDPayItem': number;
    /**
    *
    */
    'GUIDPayItem': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'Units': string;
    /**
    *
    */
    'Amount': string;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class Product {
    /**
    *
    */
    'IDProduct': number;
    /**
    *
    */
    'GUIDProduct': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'ManufacturerCode': string;
    /**
    *
    */
    'AcceptanceMethod': string;
    /**
    *
    */
    'ProductCategory': string;
    /**
    *
    */
    'CatalogCode': string;
    /**
    *
    */
    'EffectiveDate': Date;
    /**
    *
    */
    'ExpirationDate': Date;
    /**
    *
    */
    'Comments': string;
    /**
    *
    */
    'IDMaterial': number;
    /**
    *
    */
    'IDOrganization': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ProductionPlant {
    /**
    *
    */
    'IDProductionPlant': number;
    /**
    *
    */
    'GUIDProductionPlant': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'IDOrganization': number;
    /**
    *
    */
    'IDOrganizationAddress': number;
    /**
    *
    */
    'Notes': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ProductionPlantMaterialApproval {
    /**
    *
    */
    'IDProductionPlantMaterialApproval': number;
    /**
    *
    */
    'GUIDProductionPlantMaterialApproval': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDMaterial': number;
    /**
    *
    */
    'IDMixSpecification': number;
    /**
    *
    */
    'IDProductionPlant': number;
    /**
    *
    */
    'StartDate': Date;
    /**
    *
    */
    'EndDate': Date;
    /**
    *
    */
    'Notes': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ProjectModel {
    /**
    *
    */
    'Tags': Array<string>;
    /**
    *
    */
    'BidItems': Array<string>;
    /**
    *
    */
    'LineItems': Array<string>;
    /**
    *
    */
    'Contractors': Array<string>;
    /**
    *
    */
    'TagTypes': Array<string>;
    /**
    *
    */
    'LabelTypes': any;
    /**
    *
    */
    'CustomProperties': any;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'GUIDProject': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Latitude': string;
    /**
    *
    */
    'Longitude': string;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDContract': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'Timezone': string;
    /**
    *
    */
    'Status': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class QueryRequest {
    /**
    *
    */
    'Filters': Array<any>;
    /**
    *
    */
    'SelectFields': Array<any>;
    /**
    *
    */
    'Joins': Array<any>;
    /**
    *
    */
    'SortFields': Array<any>;
    /**
    *
    */
    'Begin': number;
    /**
    *
    */
    'Cap': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class RecordOfMaterial {
    /**
    *
    */
    'IDRecordOfMaterial': number;
    /**
    *
    */
    'GUIDRecordOfMaterial': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'Notes': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class RecordOfMaterialEntry {
    /**
    *
    */
    'IDRecordOfMaterialEntry': number;
    /**
    *
    */
    'GUIDRecordOfMaterialEntry': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'IDRecordOfMaterial': number;
    /**
    *
    */
    'IDBidItem': number;
    /**
    *
    */
    'IDLineItem': number;
    /**
    *
    */
    'Notes': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class RecordOfMaterialEntryArchive {
    /**
    *
    */
    'IDRecordOfMaterialEntryArchive': number;
    /**
    *
    */
    'GUIDRecordOfMaterialEntryArchive': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDRecordOfMaterialEntry': number;
    /**
    *
    */
    'RecordOfMaterialEntry': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ReportModel {
    /**
    *
    */
    'Options': any;
    /**
    *
    */
    'IDReportArchetype': number;
    /**
    *
    */
    'GUIDReportArchetype': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Archetype': string;
    /**
    *
    */
    'IDCustomer': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ReportNamedInstanceModel {
    /**
    *
    */
    'Archetype': string;
    /**
    *
    */
    'Options': any;
    /**
    *
    */
    'IDReportNamedInstance': number;
    /**
    *
    */
    'GUIDReportNamedInstance': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Hash': string;
    /**
    *
    */
    'OptionsJSON': string;
    /**
    *
    */
    'IDReportArchetype': number;
    /**
    *
    */
    'IDCustomer': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class ReportRenderResult {
    /**
    * UUID of rendered report.
    */
    'GUIDReportDescription': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class Sample {
    /**
    *
    */
    'IDSample': number;
    /**
    *
    */
    'GUIDSample': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'QRCode': string;
    /**
    *
    */
    'CaptureLatitude': string;
    /**
    *
    */
    'CaptureLongitude': string;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'ParentIDSample': number;
    /**
    *
    */
    'IDMaterial': number;
    /**
    *
    */
    'Notes': string;
    /**
    *
    */
    'IDProductionPlant': number;
    /**
    *
    */
    'IDLineItem': number;
    /**
    *
    */
    'RepresentedQuantityUnits': string;
    /**
    *
    */
    'SampledQuantityUnits': string;
    /**
    *
    */
    'LabControlNumber': string;
    /**
    *
    */
    'LabReferenceNumber': string;
    /**
    *
    */
    'ProductName': string;
    /**
    *
    */
    'MaterialType': string;
    /**
    *
    */
    'IDOrganization': number;
    /**
    *
    */
    'IDMixDesign': number;
    /**
    *
    */
    'ManufacturerCode': string;
    /**
    *
    */
    'IntendedUse': string;
    /**
    *
    */
    'BuyUSA': number;
    /**
    *
    */
    'ReceivedFrom': string;
    /**
    *
    */
    'GeographicalArea': string;
    /**
    *
    */
    'Station': string;
    /**
    *
    */
    'Offset': string;
    /**
    *
    */
    'RepresentedQuantity': string;
    /**
    *
    */
    'SampledQuantity': string;
    /**
    *
    */
    'Units': string;
    /**
    *
    */
    'RequestedBy': string;
    /**
    *
    */
    'Status': string;
    /**
    *
    */
    'ExternalSyncGUID': string;
    /**
    *
    */
    'IDLab': number;
    /**
    *
    */
    'IDProduct': number;
    /**
    *
    */
    'SampledByIDUser': number;
    /**
    *
    */
    'WitnessIDUser': number;
    /**
    *
    */
    'AuthorizedIDUser': number;
    /**
    *
    */
    'CMSIDUser': number;
    /**
    *
    */
    'Datum': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class SampleLabJoin {
    /**
    *
    */
    'IDSampleLabJoin': number;
    /**
    *
    */
    'GUIDSampleLabJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDLab': number;
    /**
    *
    */
    'IDSample': number;
    /**
    *
    */
    'Received': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class SampleLineItemJoin {
    /**
    *
    */
    'IDSampleLineItemJoin': number;
    /**
    *
    */
    'GUIDSampleLineItemJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'IDLineItem': number;
    /**
    *
    */
    'IDSample': number;
    /**
    *
    */
    'RepresentedQuantity': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class SampleLog {
    /**
    *
    */
    'IDSampleLog': number;
    /**
    *
    */
    'GUIDSampleLog': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDSample': number;
    /**
    *
    */
    'CaptureLatitude': string;
    /**
    *
    */
    'CaptureLongitude': string;
    /**
    *
    */
    'UserLatitude': string;
    /**
    *
    */
    'UserLongitude': string;
    /**
    *
    */
    'AlignmentStation': string;
    /**
    *
    */
    'AlignmentOffset': string;
    /**
    *
    */
    'Notes': string;
    /**
    *
    */
    'CaptureDate': Date;
    /**
    *
    */
    'IDLab': number;
    /**
    *
    */
    'Received': number;
    /**
    *
    */
    'ExternalSyncGUID': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class SendToEmailRequest {
    /**
    *
    */
    'IDDocument': number;
    /**
    *
    */
    'EmailAddressList': Array<string>;
    /**
    *
    */
    'Subject': string;
    /**
    *
    */
    'Message': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class Test {
    /**
    *
    */
    'IDTest': number;
    /**
    *
    */
    'GUIDTest': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Notes': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestData {
    /**
    *
    */
    'IDTestData': number;
    /**
    *
    */
    'GUIDTestData': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Hash': string;
    /**
    *
    */
    'DisplayName': string;
    /**
    *
    */
    'Type': string;
    /**
    *
    */
    'Required': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestInstance {
    /**
    *
    */
    'IDTestInstance': number;
    /**
    *
    */
    'GUIDTestInstance': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDTestPlan': number;
    /**
    *
    */
    'IDTest': number;
    /**
    *
    */
    'IDLab': number;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'IDBidItem': number;
    /**
    *
    */
    'IDLineItem': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Notes': string;
    /**
    *
    */
    'StartDate': Date;
    /**
    *
    */
    'EstimatedCompletionDate': Date;
    /**
    *
    */
    'ActualCompletionDate': Date;
    /**
    *
    */
    'ExternalSyncGUID': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestInstanceData {
    /**
    *
    */
    'IDTestInstanceData': number;
    /**
    *
    */
    'GUIDTestInstanceData': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Hash': string;
    /**
    *
    */
    'Value': string;
    /**
    *
    */
    'Comments': string;
    /**
    *
    */
    'Valid': number;
    /**
    *
    */
    'ExternalSyncGUID': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestInstanceDataArchive {
    /**
    *
    */
    'IDTestInstanceDataArchive': number;
    /**
    *
    */
    'GUIDTestInstanceDataArchive': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDTestInstanceData': number;
    /**
    *
    */
    'TestInstanceData': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestInstanceLabJoin {
    /**
    *
    */
    'IDTestInstanceLabJoin': number;
    /**
    *
    */
    'GUIDTestInstanceLabJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDTestInstance': number;
    /**
    *
    */
    'IDLab': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestInstanceSampleJoin {
    /**
    *
    */
    'IDTestInstanceSampleJoin': number;
    /**
    *
    */
    'GUIDTestInstanceSampleJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDTestInstance': number;
    /**
    *
    */
    'IDSample': number;
    /**
    *
    */
    'IDCustomer': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestLabJoin {
    /**
    *
    */
    'IDTestLabJoin': number;
    /**
    *
    */
    'GUIDTestLabJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDLab': number;
    /**
    *
    */
    'IDLabParent': number;
    /**
    *
    */
    'IDTest': number;
    /**
    *
    */
    'DateEnd': Date;
    /**
    *
    */
    'QualificationType': string;
    /**
    *
    */
    'QualificationMethod': string;
    /**
    *
    */
    'QualificationAuthorization': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestPlan {
    /**
    *
    */
    'IDTestPlan': number;
    /**
    *
    */
    'GUIDTestPlan': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'Description': string;
    /**
    *
    */
    'DateStart': Date;
    /**
    *
    */
    'DateEnd': Date;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestRecordOfMaterialEntryJoin {
    /**
    *
    */
    'IDTestRecordOfMaterialEntryJoin': number;
    /**
    *
    */
    'GUIDTestRecordOfMaterialEntryJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDTestPlan': number;
    /**
    *
    */
    'IDTest': number;
    /**
    *
    */
    'IDLab': number;
    /**
    *
    */
    'IDProject': number;
    /**
    *
    */
    'IDBidItem': number;
    /**
    *
    */
    'IDLineItem': number;
    /**
    *
    */
    'TestCount': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Notes': string;
    /**
    *
    */
    'IDRecordOfMaterialEntry': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestSpecification {
    /**
    *
    */
    'IDTestSpecification': number;
    /**
    *
    */
    'GUIDTestSpecification': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'IDTestSpecificationSet': number;
    /**
    *
    */
    'Description': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestSpecificationMaterialTestJoin {
    /**
    *
    */
    'IDTestSpecificationMaterialTestJoin': number;
    /**
    *
    */
    'GUIDTestSpecificationMaterialTestJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDTestSpecification': number;
    /**
    *
    */
    'IDMaterial': number;
    /**
    *
    */
    'IDTest': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestSpecificationRequirement {
    /**
    *
    */
    'IDTestSpecificationRequirement': number;
    /**
    *
    */
    'GUIDTestSpecificationRequirement': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDTestSpecification': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Ordinal': string;
    /**
    *
    */
    'OperationType': string;
    /**
    *
    */
    'ValueMinimum': string;
    /**
    *
    */
    'ValueMaximum': string;
    /**
    *
    */
    'ComputationTemplate': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestSpecificationSet {
    /**
    *
    */
    'IDTestSpecificationSet': number;
    /**
    *
    */
    'GUIDTestSpecificationSet': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Year': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestSpecificationSetTestJoin {
    /**
    *
    */
    'IDTestSpecificationSetTestJoin': number;
    /**
    *
    */
    'GUIDTestSpecificationSetTestJoin': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'IDTestSpecificationSet': number;
    /**
    *
    */
    'IDTest': number;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class TestStep {
    /**
    *
    */
    'IDTestStep': number;
    /**
    *
    */
    'GUIDTestStep': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'Name': string;
    /**
    *
    */
    'Notes': string;
    /**
    *
    */
    'Computed': number;
    /**
    *
    */
    'ComputationTemplate': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class UserModel {
    /**
    *
    */
    'Settings': any;
    /**
    *
    */
    'IDUser': number;
    /**
    *
    */
    'GUIDUser': string;
    /**
    *
    */
    'CreateDate': Date;
    /**
    *
    */
    'CreatingIDUser': number;
    /**
    *
    */
    'UpdateDate': Date;
    /**
    *
    */
    'UpdatingIDUser': number;
    /**
    *
    */
    'Deleted': number;
    /**
    *
    */
    'DeleteDate': Date;
    /**
    *
    */
    'DeletingIDUser': number;
    /**
    *
    */
    'NameFirst': string;
    /**
    *
    */
    'NameLast': string;
    /**
    *
    */
    'Email': string;
    /**
    *
    */
    'LoginID': string;
    /**
    *
    */
    'IDRole': number;
    /**
    *
    */
    'Title': string;
    /**
    *
    */
    'Classification': string;
    /**
    *
    */
    'IDProjectOffice': number;
    /**
    *
    */
    'IDCustomer': number;
    /**
    *
    */
    'EmailPending': number;
    /**
    *
    */
    'Phone': string;
    /**
    *
    */
    'UIHash': string;
    /**
    *
    */
    'Timezone': string;
    /**
    *
    */
    'Shift': string;
    /**
    *
    */
    'ExternalSyncDate': Date;
    /**
    *
    */
    'LastLoginTime': Date;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class UserSignupRequest {
    /**
    *
    */
    'NameFirst': string;
    /**
    *
    */
    'NameLast': string;
    /**
    *
    */
    'Email': string;
    /**
    *
    */
    'Password': string;
    /**
    *
    */
    'Phone': string;
    /**
    *
    */
    'CompanyName': string;
    'CompanyDetails': UserSignupRequestCompanyDetails;
    /**
    *
    */
    'Position': string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
/**
*
*/
export declare class UserSignupRequestCompanyDetails {
    /**
    *
    */
    'State'?: string;
    /**
    *
    */
    'Size'?: number;
    /**
    *
    */
    'EstimatedAnnualRevenue'?: string;
    static discriminator: string | undefined;
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
}
export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
    executeWithAuth<T>(requestOptions: localVarRequest.Options, requestDelegate: () => Promise<T>): Promise<T>;
}
export declare class HttpBasicAuth implements Authentication {
    username: string;
    password: string;
    applyToRequest(requestOptions: localVarRequest.Options): void;
    executeWithAuth<T>(requestOptions: localVarRequest.Options, requestDelegate: () => Promise<T>): Promise<T>;
}
export declare class ApiKeyAuth implements Authentication {
    private location;
    private paramName;
    apiKey: string;
    constructor(location: string, paramName: string);
    applyToRequest(requestOptions: localVarRequest.Options): void;
    executeWithAuth<T>(requestOptions: localVarRequest.Options, requestDelegate: () => Promise<T>): Promise<T>;
}
export declare class OAuth implements Authentication {
    accessToken: string;
    applyToRequest(requestOptions: localVarRequest.Options): void;
    executeWithAuth<T>(requestOptions: localVarRequest.Options, requestDelegate: () => Promise<T>): Promise<T>;
}
export declare class VoidAuth implements Authentication {
    username: string;
    password: string;
    applyToRequest(_: localVarRequest.Options): void;
    executeWithAuth<T>(requestOptions: localVarRequest.Options, requestDelegate: () => Promise<T>): Promise<T>;
}
export declare enum ArtifactApiApiKeys {
}
export declare class ArtifactApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ArtifactApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Switch Artifact records Sync flag
     * @param IDArtifact ID of record
     */
    clearArtifactSyncFlag(IDArtifact: number): Promise<any>;
    /**
     * Copy Artifact media from ID to target ID
     * @param IDTargetArtifact ID of record
     * @param IDObservationArtifact ID of record
     * @param ArtifactVersion
     * @param TargetArtifactVersion
     */
    copyArtifact(IDTargetArtifact: number, IDObservationArtifact: number, ArtifactVersion: number, TargetArtifactVersion: number): Promise<any>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: ArtifactModel): Promise<ArtifactModel>;
    /**
     * Download Artifact media file from Headlight
     * @param IDObservationArtifact ID of record
     * @param Size
     * @param ArtifactVersion
     */
    downloadArtifact(IDObservationArtifact: number, Size: string, ArtifactVersion: string): Promise<Buffer>;
    /**
     * Get Artifact records for media types that don't have the Sync flag set
     */
    getArtifactSyncList(): Promise<Array<Artifact>>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<ArtifactModel>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<ArtifactModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<ArtifactModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<ArtifactModel>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: ArtifactModel): Promise<ArtifactModel>;
    /**
     * Upload Artifact media file to Headlight
     * @param IDObservationArtifact ID of record
     * @param file
     * @param ArtifactVersion
     */
    uploadArtifact(IDObservationArtifact: number, file: Buffer, ArtifactVersion: number): Promise<any>;
    getLastResponse(): any;
}
export declare enum AuthenticateApiApiKeys {
}
export declare class AuthenticateApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: AuthenticateApiApiKeys, value: string): void;
    /**
     * Forward authentication request to authentication microservice.
     * @param body
     */
    authenticate(body: LoginRequest): Promise<ISession>;
    /**
     * Get current session state from server
     */
    checkSession(): Promise<ISession>;
    /**
     * Check out temporary authentication token for user in session.
     */
    checkoutSessionToken(): Promise<InlineResponse2001>;
    /**
     * Logout user (remove session from server)
     */
    deAuthenticate(): Promise<InlineResponse2002>;
    /**
     * Impersonate another user, according to access rights.
     * @param IDUser
     */
    impersonateUser(IDUser: number): Promise<any>;
    getLastResponse(): any;
}
export declare enum BatchExportApiApiKeys {
}
export declare class BatchExportApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: BatchExportApiApiKeys, value: string): void;
    /**
     * Begin Batch Export Job
     */
    batchExport(): Promise<any>;
    /**
     * List export files that are ready for download
     * @param ExportType
     */
    batchExportListFiles(ExportType: string): Promise<any>;
    getLastResponse(): any;
}
export declare enum BidItemApiApiKeys {
}
export declare class BidItemApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: BidItemApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: BidItem): Promise<BidItem>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<BidItem>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<BidItem>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<BidItem>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<BidItem>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: BidItem): Promise<BidItem>;
    getLastResponse(): any;
}
export declare enum CommentApiApiKeys {
}
export declare class CommentApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: CommentApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: CommentModel): Promise<CommentModel>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<CommentModel>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<CommentModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<CommentModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<CommentModel>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: CommentModel): Promise<CommentModel>;
    getLastResponse(): any;
}
export declare enum ContractApiApiKeys {
}
export declare class ContractApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ContractApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: Contract): Promise<Contract>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<Contract>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<Contract>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<Contract>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<Contract>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: Contract): Promise<Contract>;
    getLastResponse(): any;
}
export declare enum CustomerApiApiKeys {
}
export declare class CustomerApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: CustomerApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: Customer): Promise<Customer>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<Customer>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<Customer>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<Customer>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<Customer>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: Customer): Promise<Customer>;
    getLastResponse(): any;
}
export declare enum DocumentApiApiKeys {
}
export declare class DocumentApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: DocumentApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     *
     * @param IDComment ID of record
     * @param IDDocument ID of record
     */
    addCommentsToDocument(IDComment: number, IDDocument: number): Promise<any>;
    /**
     *
     * @param IDObservation ID of record
     * @param IDDocument ID of record
     */
    addDocumentObservation(IDObservation: number, IDDocument: number): Promise<any>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: DocumentModel): Promise<DocumentModel>;
    /**
     * Get Document count form beginning of month in Customer timezone UP TO target DocumentID
     * @param IDDocument ID of record
     */
    getDocumentCountBySequenceNumber(IDDocument: number): Promise<any>;
    /**
     * Generate a DCR in HTML format
     * @param IDDocument ID of record
     */
    getDocumentHTML(IDDocument: number): Promise<any>;
    /**
     * Generate a DCR in JSON format
     * @param IDDocument ID of record
     */
    getDocumentJSON(IDDocument: number): Promise<any>;
    /**
     * Generate a DCR in PDF format
     * @param IDDocument ID of record
     */
    getDocumentPDF(IDDocument: number): Promise<Buffer>;
    /**
     * Get Report Parameters that being sent to the report service
     * @param IDDocument ID of record
     */
    getDocumentReportParameters(IDDocument: number): Promise<any>;
    /**
     * Allows a report to perform a bulk upsert in context of a document.
     * @param body
     */
    postFormProcessor(body: FormProcessorRequest): Promise<any>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<DocumentModel>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<DocumentModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<DocumentModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<DocumentModel>>;
    /**
     *
     * @param IDObservation ID of record
     * @param IDDocument ID of record
     */
    removeDocumentObservation(IDObservation: number, IDDocument: number): Promise<any>;
    /**
     * Attach an ElectronicSignature to a Document
     * @param IDElectronicSignature ID of record
     * @param IDDocument ID of record
     */
    signDocument(IDElectronicSignature: number, IDDocument: number): Promise<any>;
    /**
     * UNDelete a specific Document
     * @param IDDocument ID of record
     */
    undeleteDocument(IDDocument: number): Promise<any>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: DocumentModel): Promise<DocumentModel>;
    /**
     * Update Document ExternalSyncDate field
     */
    updateDocumentExternalSyncDate(): Promise<any>;
    getLastResponse(): any;
}
export declare enum DocumentApprovalApiApiKeys {
}
export declare class DocumentApprovalApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: DocumentApprovalApiApiKeys, value: string): void;
    /**
     * Get list of Approvers for Document
     * @param IDDocument ID of record
     */
    getDocumentApproverList(IDDocument: number): Promise<any>;
    /**
     * Get current Approval state of Document, and available actions for respective user as it relates to that state
     * @param IDDocument ID of record
     */
    getDocumentState(IDDocument: number): Promise<any>;
    /**
     * Perform Approval state transition action against Document
     * @param body
     */
    postChangeDocumenttState(body: DocumentStateChangeRequest): Promise<any>;
    getLastResponse(): any;
}
export declare enum DocumentSendToApiApiKeys {
}
export declare class DocumentSendToApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: DocumentSendToApiApiKeys, value: string): void;
    /**
     *
     * @param IDDocument ID of record
     * @param body
     */
    postDocumentSendToEmail(IDDocument: number, body: SendToEmailRequest): Promise<any>;
    getLastResponse(): any;
}
export declare enum DocumentsApiApiKeys {
}
export declare class DocumentsApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: DocumentsApiApiKeys, value: string): void;
    /**
     * Get all Document records for this user that have changed since the sync date
     * @param SynchronizeFromDate FROM date (descending)
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    getUpdatedDocuments(SynchronizeFromDate: Date, Begin: number, Cap: number): Promise<any>;
    /**
     * Sync Documents  Process (since this is so complex): 1. FOR EACH Document     1.1 Archive the Document     1.2 Merge in the Changes     1.5 After all Detail records are successfully stored, Update Document so Document.definition contains the serialized array of Details 2. Get all Document records for this user that have changed since the sync date
     * @param SynchronizeFromDate FROM date (descending)
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    syncDocuments(SynchronizeFromDate: Date, Begin: number, Cap: number): Promise<any>;
    getLastResponse(): any;
}
export declare enum DocumentsByObservationApiApiKeys {
}
export declare class DocumentsByObservationApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: DocumentsByObservationApiApiKeys, value: string): void;
    /**
     *
     * @param IDObservation ID of record
     */
    getDocumentByObservation(IDObservation: number): Promise<any>;
    getLastResponse(): any;
}
export declare enum ElectronicSignatureApiApiKeys {
}
export declare class ElectronicSignatureApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ElectronicSignatureApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: ElectronicSignatureModel): Promise<ElectronicSignatureModel>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<ElectronicSignatureModel>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<ElectronicSignatureModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<ElectronicSignatureModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<ElectronicSignatureModel>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: ElectronicSignatureModel): Promise<ElectronicSignatureModel>;
    getLastResponse(): any;
}
export declare enum EquipmentApiApiKeys {
}
export declare class EquipmentApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: EquipmentApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: Equipment): Promise<Equipment>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<Equipment>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<Equipment>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<Equipment>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<Equipment>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: Equipment): Promise<Equipment>;
    getLastResponse(): any;
}
export declare enum LabApiApiKeys {
}
export declare class LabApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: LabApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: Lab): Promise<Lab>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<Lab>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<Lab>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<Lab>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<Lab>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: Lab): Promise<Lab>;
    getLastResponse(): any;
}
export declare enum LabMaterialAssignmentApiApiKeys {
}
export declare class LabMaterialAssignmentApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: LabMaterialAssignmentApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: LabMaterialAssignment): Promise<LabMaterialAssignment>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<LabMaterialAssignment>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<LabMaterialAssignment>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<LabMaterialAssignment>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<LabMaterialAssignment>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: LabMaterialAssignment): Promise<LabMaterialAssignment>;
    getLastResponse(): any;
}
export declare enum LabTestApprovalApiApiKeys {
}
export declare class LabTestApprovalApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: LabTestApprovalApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: LabTestApproval): Promise<LabTestApproval>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<LabTestApproval>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<LabTestApproval>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<LabTestApproval>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<LabTestApproval>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: LabTestApproval): Promise<LabTestApproval>;
    getLastResponse(): any;
}
export declare enum LabTestDefaultApiApiKeys {
}
export declare class LabTestDefaultApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: LabTestDefaultApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: LabTestDefault): Promise<LabTestDefault>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<LabTestDefault>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<LabTestDefault>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<LabTestDefault>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<LabTestDefault>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: LabTestDefault): Promise<LabTestDefault>;
    getLastResponse(): any;
}
export declare enum LineItemApiApiKeys {
}
export declare class LineItemApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: LineItemApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: LineItem): Promise<LineItem>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<LineItem>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<LineItem>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<LineItem>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<LineItem>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: LineItem): Promise<LineItem>;
    getLastResponse(): any;
}
export declare enum MaterialApiApiKeys {
}
export declare class MaterialApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: MaterialApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: Material): Promise<Material>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<Material>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<Material>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<Material>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<Material>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: Material): Promise<Material>;
    getLastResponse(): any;
}
export declare enum MaterialLineItemJoinApiApiKeys {
}
export declare class MaterialLineItemJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: MaterialLineItemJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: MaterialLineItemJoin): Promise<MaterialLineItemJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<MaterialLineItemJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<MaterialLineItemJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<MaterialLineItemJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<MaterialLineItemJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: MaterialLineItemJoin): Promise<MaterialLineItemJoin>;
    getLastResponse(): any;
}
export declare enum MaterialPayItemJoinApiApiKeys {
}
export declare class MaterialPayItemJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: MaterialPayItemJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: MaterialPayItemJoin): Promise<MaterialPayItemJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<MaterialPayItemJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<MaterialPayItemJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<MaterialPayItemJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<MaterialPayItemJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: MaterialPayItemJoin): Promise<MaterialPayItemJoin>;
    getLastResponse(): any;
}
export declare enum MaterialRecordOfMaterialEntryJoinApiApiKeys {
}
export declare class MaterialRecordOfMaterialEntryJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: MaterialRecordOfMaterialEntryJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: MaterialRecordOfMaterialEntryJoin): Promise<MaterialRecordOfMaterialEntryJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<MaterialRecordOfMaterialEntryJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<MaterialRecordOfMaterialEntryJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<MaterialRecordOfMaterialEntryJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<MaterialRecordOfMaterialEntryJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: MaterialRecordOfMaterialEntryJoin): Promise<MaterialRecordOfMaterialEntryJoin>;
    getLastResponse(): any;
}
export declare enum MixSpecificationApiApiKeys {
}
export declare class MixSpecificationApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: MixSpecificationApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: MixSpecification): Promise<MixSpecification>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<MixSpecification>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<MixSpecification>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<MixSpecification>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<MixSpecification>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: MixSpecification): Promise<MixSpecification>;
    getLastResponse(): any;
}
export declare enum MixSpecificationMaterialJoinApiApiKeys {
}
export declare class MixSpecificationMaterialJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: MixSpecificationMaterialJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: MixSpecificationMaterialJoin): Promise<MixSpecificationMaterialJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<MixSpecificationMaterialJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<MixSpecificationMaterialJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<MixSpecificationMaterialJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<MixSpecificationMaterialJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: MixSpecificationMaterialJoin): Promise<MixSpecificationMaterialJoin>;
    getLastResponse(): any;
}
export declare enum ModuleApiApiKeys {
}
export declare class ModuleApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ModuleApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: ModuleModel): Promise<ModuleModel>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<ModuleModel>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<ModuleModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<ModuleModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<ModuleModel>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: ModuleModel): Promise<ModuleModel>;
    getLastResponse(): any;
}
export declare enum NotificationApiApiKeys {
}
export declare class NotificationApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: NotificationApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: Notification): Promise<Notification>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<Notification>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<Notification>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<Notification>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<Notification>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: Notification): Promise<Notification>;
    getLastResponse(): any;
}
export declare enum ObservationApiApiKeys {
}
export declare class ObservationApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ObservationApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Index all Observations for a single day (solr)
     * @param SynchronizeByDay
     */
    beginIndexByDay(SynchronizeByDay: string): Promise<any>;
    /**
     * Index all Observations for a single project (solr)
     * @param IDProject ID of record
     */
    beginIndexByProject(IDProject: number): Promise<any>;
    /**
     * Delete and rebuild entire Observation search index (solr)
     */
    beginObservationSearchRebuild(): Promise<any>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: ObservationModel): Promise<ObservationModel>;
    /**
     *
     * @param IDProject ID of record
     * @param SpritePageNumber
     */
    downloadObservationCollectionImage(IDProject: number, SpritePageNumber: number): Promise<Buffer>;
    /**
     * Download Observation Image - Get transcoded media file for an observation. If not found, asks transcoder to regenerate it
     * @param IDObservation ID of record
     * @param Size e.g. Thumbnail,Standard,Preview,Enhanced
     */
    downloadObservationImage(IDObservation: number, Size: string): Promise<Buffer>;
    /**
     * Get Observation Image Hash - Get time on observation media item from mongo.
     * @param Size e.g. Thumbnail,Standard,Preview,Enhanced
     * @param Version
     */
    getObservationImageHash(Size: string, Version: number): Promise<any>;
    /**
     *
     * @param SynchronizeFromDate
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    getUpdatedObservations(SynchronizeFromDate: Date, Begin: number, Cap: number): Promise<Array<ObservationModel>>;
    /**
     * postCloneBulkObservations API
     * @param body
     */
    postCloneBulkObservations(body: ObservationCloneRequest): Promise<Array<ObservationModel>>;
    /**
     * postCloneObservation API
     * @param IDObservation ID of record
     */
    postCloneObservation(IDObservation: number): Promise<ObservationModel>;
    /**
     * Add a tag to a set of Observations (by ID)
     */
    postObservationsBatchTagAdd(): Promise<any>;
    /**
     * Remove a tag to a set of Observations (by ID)
     */
    postObservationsBatchTagRemove(): Promise<any>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<ObservationModel>>;
    /**
     * Index specific Observations (solr)
     * @param IDObservation ID of record
     */
    pushObservationSearchIndexByIDs(IDObservation: number): Promise<any>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<ObservationModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<ObservationModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<ObservationModel>>;
    /**
     * Sync Observations  Process (since this is so complex): 1. FOR EACH OBSERVATION     1.1 Archive the Observation     1.2 Merge in the Changes     1.3 Translate the Observation Details     1.4 PERFORM SYNC MATCH AND UPDATE WHERE NECESSARY (TALK TO TRENT)     1.5 After all Detail records are successfully stored, Update Observation so Observation.definition contains the serialized array of Details 2. Get all observation records for this user that have changed since the sync date
     * @param SynchronizeFromDate
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    syncObservations(SynchronizeFromDate: Date, Begin: number, Cap: number): Promise<any>;
    /**
     * Touch Observation record UpdateDate and set Transcoded flag - When media files are updated, we want other devices to see the changes and pull it down
     * @param IDObservation ID of record
     */
    transcodeTouchObservation(IDObservation: number): Promise<any>;
    /**
     * UNDelete a specific observation
     * @param IDObservation ID of record
     */
    undeleteObservation(IDObservation: number): Promise<any>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: ObservationModel): Promise<ObservationModel>;
    getLastResponse(): any;
}
export declare enum ObservationApprovalApiApiKeys {
}
export declare class ObservationApprovalApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ObservationApprovalApiApiKeys, value: string): void;
    /**
     * Get list of Approvers for Observation
     * @param IDObservation ID of record
     */
    getObservationApproverList(IDObservation: number): Promise<any>;
    /**
     * Get current Approval state of Observation, and available actions for respective user as it relates to that state
     * @param IDObservation ID of record
     */
    getObservationState(IDObservation: number): Promise<any>;
    /**
     * Perform Approval state transition action against Observation
     */
    postChangeObservationtState(): Promise<any>;
    getLastResponse(): any;
}
export declare enum ObservationCloneTemplatesApiApiKeys {
}
export declare class ObservationCloneTemplatesApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ObservationCloneTemplatesApiApiKeys, value: string): void;
    /**
     *
     * @param IDProject ID of record
     */
    getCloneTemplates(IDProject: number): Promise<any>;
    getLastResponse(): any;
}
export declare enum ObservationSearchsApiApiKeys {
}
export declare class ObservationSearchsApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ObservationSearchsApiApiKeys, value: string): void;
    /**
     * Search Observations using search index (solr)
     * @param IDProject ID of record
     * @param Begin Beginning (skip) number of records (to page)
     * @param SearchQuery solr search query
     * @param Cap Maximum number of records to return
     */
    getObservationSearch(IDProject: number, Begin: number, SearchQuery: string, Cap: number): Promise<any>;
    /**
     * Search Observations using search index (solr)
     * @param IDProject ID of record
     * @param SearchQuery solr search query
     */
    getObservationSearchCount(IDProject: number, SearchQuery: string): Promise<any>;
    getLastResponse(): any;
}
export declare enum ObservationSendToApiApiKeys {
}
export declare class ObservationSendToApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ObservationSendToApiApiKeys, value: string): void;
    /**
     *
     * @param IDObservation ID of record
     * @param EmailAddress
     */
    getObservationSendToEmail(IDObservation: number, EmailAddress: string): Promise<any>;
    /**
     *
     */
    postObservationSendToEmail(): Promise<any>;
    getLastResponse(): any;
}
export declare enum ObservationsBatchTagApiApiKeys {
}
export declare class ObservationsBatchTagApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ObservationsBatchTagApiApiKeys, value: string): void;
    /**
     * Add a tag to a set of Observations (by ID)
     */
    postObservationsBatchTagAdd(): Promise<any>;
    /**
     * Remove a tag to a set of Observations (by ID)
     */
    postObservationsBatchTagRemove(): Promise<any>;
    getLastResponse(): any;
}
export declare enum ObservationsByDocumentApiApiKeys {
}
export declare class ObservationsByDocumentApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ObservationsByDocumentApiApiKeys, value: string): void;
    /**
     * Find all observations associated to a document.
     * @param IDDocument ID of record
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    getObservationsByDocument(IDDocument: number, Begin: number, Cap: number): Promise<any>;
    /**
     * Find observations NOT associated to any documents.
     * @param IDProject ID of record
     * @param Cap Maximum number of records to return
     */
    getObservationsByNoDocument(IDProject: number, Cap: number): Promise<any>;
    getLastResponse(): any;
}
export declare enum ObservationsByUpdateDateApiApiKeys {
}
export declare class ObservationsByUpdateDateApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ObservationsByUpdateDateApiApiKeys, value: string): void;
    /**
     * Fetch list of observations where date is earlier than ByDate.
     * @param ByDate
     * @param Cap Maximum number of records to return
     */
    getObservationsByUpdateDate(ByDate: Date, Cap: number): Promise<any>;
    getLastResponse(): any;
}
export declare enum ObservationsFilterApiApiKeys {
}
export declare class ObservationsFilterApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ObservationsFilterApiApiKeys, value: string): void;
    /**
     * Search Observations using search index (solr)
     * @param body
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    getObservationsFilter(body: ObservationFilterRequest, Begin: number, Cap: number): Promise<any>;
    /**
     * Search Observations using search index (solr)
     * @param body
     */
    getObservationsFilterCount(body: ObservationFilterRequest): Promise<any>;
    getLastResponse(): any;
}
export declare enum OrganizationApiApiKeys {
}
export declare class OrganizationApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: OrganizationApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: Organization): Promise<Organization>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<Organization>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<Organization>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<Organization>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<Organization>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: Organization): Promise<Organization>;
    getLastResponse(): any;
}
export declare enum OrganizationMaterialJoinApiApiKeys {
}
export declare class OrganizationMaterialJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: OrganizationMaterialJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: OrganizationMaterialJoin): Promise<OrganizationMaterialJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<OrganizationMaterialJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<OrganizationMaterialJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<OrganizationMaterialJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<OrganizationMaterialJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: OrganizationMaterialJoin): Promise<OrganizationMaterialJoin>;
    getLastResponse(): any;
}
export declare enum PayItemApiApiKeys {
}
export declare class PayItemApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: PayItemApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: PayItemModel): Promise<PayItemModel>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<PayItemModel>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<PayItemModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<PayItemModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<PayItemModel>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: PayItemModel): Promise<PayItemModel>;
    getLastResponse(): any;
}
export declare enum ProductApiApiKeys {
}
export declare class ProductApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ProductApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: Product): Promise<Product>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<Product>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<Product>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<Product>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<Product>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: Product): Promise<Product>;
    getLastResponse(): any;
}
export declare enum ProductionPlantApiApiKeys {
}
export declare class ProductionPlantApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ProductionPlantApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: ProductionPlant): Promise<ProductionPlant>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<ProductionPlant>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<ProductionPlant>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<ProductionPlant>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<ProductionPlant>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: ProductionPlant): Promise<ProductionPlant>;
    getLastResponse(): any;
}
export declare enum ProductionPlantMaterialApprovalApiApiKeys {
}
export declare class ProductionPlantMaterialApprovalApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ProductionPlantMaterialApprovalApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: ProductionPlantMaterialApproval): Promise<ProductionPlantMaterialApproval>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<ProductionPlantMaterialApproval>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<ProductionPlantMaterialApproval>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<ProductionPlantMaterialApproval>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<ProductionPlantMaterialApproval>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: ProductionPlantMaterialApproval): Promise<ProductionPlantMaterialApproval>;
    getLastResponse(): any;
}
export declare enum ProjectApiApiKeys {
}
export declare class ProjectApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ProjectApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: ProjectModel): Promise<ProjectModel>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<ProjectModel>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<ProjectModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<ProjectModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<ProjectModel>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: ProjectModel): Promise<ProjectModel>;
    getLastResponse(): any;
}
export declare enum RecordOfMaterialApiApiKeys {
}
export declare class RecordOfMaterialApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: RecordOfMaterialApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: RecordOfMaterial): Promise<RecordOfMaterial>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<RecordOfMaterial>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<RecordOfMaterial>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<RecordOfMaterial>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<RecordOfMaterial>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: RecordOfMaterial): Promise<RecordOfMaterial>;
    getLastResponse(): any;
}
export declare enum RecordOfMaterialEntryApiApiKeys {
}
export declare class RecordOfMaterialEntryApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: RecordOfMaterialEntryApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: RecordOfMaterialEntry): Promise<RecordOfMaterialEntry>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<RecordOfMaterialEntry>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<RecordOfMaterialEntry>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<RecordOfMaterialEntry>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<RecordOfMaterialEntry>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: RecordOfMaterialEntry): Promise<RecordOfMaterialEntry>;
    getLastResponse(): any;
}
export declare enum RecordOfMaterialEntryArchiveApiApiKeys {
}
export declare class RecordOfMaterialEntryArchiveApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: RecordOfMaterialEntryArchiveApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: RecordOfMaterialEntryArchive): Promise<RecordOfMaterialEntryArchive>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<RecordOfMaterialEntryArchive>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<RecordOfMaterialEntryArchive>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<RecordOfMaterialEntryArchive>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<RecordOfMaterialEntryArchive>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: RecordOfMaterialEntryArchive): Promise<RecordOfMaterialEntryArchive>;
    getLastResponse(): any;
}
export declare enum ReportApiApiKeys {
}
export declare class ReportApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ReportApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: ReportModel): Promise<ReportModel>;
    /**
     * Get list of available render types for a document type. (pdf, html, etc.)
     * @param ReportType Report type name (e.g. &#39;DCR&#39;, &#39;Headlight-Daily&#39;, etc)
     */
    getDocumentRenderByType(ReportType: string): Promise<any>;
    /**
     * Request to render a report. To get rendered files, use getReportStageFile() Example HTML flow: 1. Request /Report/Render/1247/default 2. Extract GUIDReportDescription (i.e. \"0x5984be9c8b000000\") from response object. 3. Open a new browser tab to: /Report/0x5984be9c8b000000/ 4. Rendered html page will subsequently request assets (images, css, etc)
     * @param IDDocument ID of record
     * @param Renderer Render format (default, html, pdf, json, etc)
     */
    getRenderReport(IDDocument: number, Renderer: string): Promise<ReportRenderResult>;
    /**
     * Source JSON datum used to generate the report.
     * @param ReportUUID UUID of completed report render.
     */
    getReportDatum(ReportUUID: string): Promise<any>;
    /**
     * Manifest (JSON metadata file) about the rendered report. Includes information about other generated assets.
     * @param ReportUUID UUID of completed report render.
     */
    getReportManifest(ReportUUID: string): Promise<any>;
    /**
     * Get staged (rendered) file for a previously rendered report.
     * @param ReportUUID UUID of completed report render.
     * @param StageFilePath Subpath to file in rendered report stage dir
     */
    getReportStageFile(ReportUUID: string, StageFilePath: string): Promise<Buffer>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<ReportModel>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<ReportModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<ReportModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<ReportModel>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: ReportModel): Promise<ReportModel>;
    getLastResponse(): any;
}
export declare enum ReportNamedInstanceApiApiKeys {
}
export declare class ReportNamedInstanceApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: ReportNamedInstanceApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     *
     * @param IDProject ID of record
     * @param IDReportNamedInstance ID of record
     */
    addReportNamedInstanceToProject(IDProject: number, IDReportNamedInstance: number): Promise<any>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: ReportNamedInstanceModel): Promise<ReportNamedInstanceModel>;
    /**
     *
     * @param IDProject ID of record
     * @param Begin Beginning (skip) number of records (to page)
     * @param Cap Maximum number of records to return
     */
    getReportNamedInstanceByProject(IDProject: number, Begin: number, Cap: number): Promise<any>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<ReportNamedInstanceModel>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<ReportNamedInstanceModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<ReportNamedInstanceModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<ReportNamedInstanceModel>>;
    /**
     *
     * @param IDProject ID of record
     * @param IDReportNamedInstance ID of record
     */
    removeReportNamedInstanceFromProject(IDProject: number, IDReportNamedInstance: number): Promise<any>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: ReportNamedInstanceModel): Promise<ReportNamedInstanceModel>;
    getLastResponse(): any;
}
export declare enum SampleApiApiKeys {
}
export declare class SampleApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: SampleApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: Sample): Promise<Sample>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<Sample>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<Sample>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<Sample>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<Sample>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: Sample): Promise<Sample>;
    getLastResponse(): any;
}
export declare enum SampleLabJoinApiApiKeys {
}
export declare class SampleLabJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: SampleLabJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: SampleLabJoin): Promise<SampleLabJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<SampleLabJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<SampleLabJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<SampleLabJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<SampleLabJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: SampleLabJoin): Promise<SampleLabJoin>;
    getLastResponse(): any;
}
export declare enum SampleLineItemJoinApiApiKeys {
}
export declare class SampleLineItemJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: SampleLineItemJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: SampleLineItemJoin): Promise<SampleLineItemJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<SampleLineItemJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<SampleLineItemJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<SampleLineItemJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<SampleLineItemJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: SampleLineItemJoin): Promise<SampleLineItemJoin>;
    getLastResponse(): any;
}
export declare enum SampleLogApiApiKeys {
}
export declare class SampleLogApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: SampleLogApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: SampleLog): Promise<SampleLog>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<SampleLog>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<SampleLog>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<SampleLog>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<SampleLog>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: SampleLog): Promise<SampleLog>;
    getLastResponse(): any;
}
export declare enum TestApiApiKeys {
}
export declare class TestApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: Test): Promise<Test>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<Test>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<Test>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<Test>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<Test>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: Test): Promise<Test>;
    getLastResponse(): any;
}
export declare enum TestDataApiApiKeys {
}
export declare class TestDataApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestDataApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestData): Promise<TestData>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestData>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestData>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestData>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestData>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestData): Promise<TestData>;
    getLastResponse(): any;
}
export declare enum TestInstanceApiApiKeys {
}
export declare class TestInstanceApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestInstanceApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestInstance): Promise<TestInstance>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestInstance>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestInstance>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestInstance>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestInstance>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestInstance): Promise<TestInstance>;
    getLastResponse(): any;
}
export declare enum TestInstanceDataApiApiKeys {
}
export declare class TestInstanceDataApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestInstanceDataApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestInstanceData): Promise<TestInstanceData>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestInstanceData>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestInstanceData>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestInstanceData>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestInstanceData>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestInstanceData): Promise<TestInstanceData>;
    getLastResponse(): any;
}
export declare enum TestInstanceDataArchiveApiApiKeys {
}
export declare class TestInstanceDataArchiveApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestInstanceDataArchiveApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestInstanceDataArchive): Promise<TestInstanceDataArchive>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestInstanceDataArchive>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestInstanceDataArchive>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestInstanceDataArchive>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestInstanceDataArchive>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestInstanceDataArchive): Promise<TestInstanceDataArchive>;
    getLastResponse(): any;
}
export declare enum TestInstanceLabJoinApiApiKeys {
}
export declare class TestInstanceLabJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestInstanceLabJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestInstanceLabJoin): Promise<TestInstanceLabJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestInstanceLabJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestInstanceLabJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestInstanceLabJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestInstanceLabJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestInstanceLabJoin): Promise<TestInstanceLabJoin>;
    getLastResponse(): any;
}
export declare enum TestInstanceSampleJoinApiApiKeys {
}
export declare class TestInstanceSampleJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestInstanceSampleJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestInstanceSampleJoin): Promise<TestInstanceSampleJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestInstanceSampleJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestInstanceSampleJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestInstanceSampleJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestInstanceSampleJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestInstanceSampleJoin): Promise<TestInstanceSampleJoin>;
    getLastResponse(): any;
}
export declare enum TestLabJoinApiApiKeys {
}
export declare class TestLabJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestLabJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestLabJoin): Promise<TestLabJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestLabJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestLabJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestLabJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestLabJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestLabJoin): Promise<TestLabJoin>;
    getLastResponse(): any;
}
export declare enum TestPlanApiApiKeys {
}
export declare class TestPlanApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestPlanApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestPlan): Promise<TestPlan>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestPlan>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestPlan>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestPlan>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestPlan>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestPlan): Promise<TestPlan>;
    getLastResponse(): any;
}
export declare enum TestRecordOfMaterialEntryJoinApiApiKeys {
}
export declare class TestRecordOfMaterialEntryJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestRecordOfMaterialEntryJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestRecordOfMaterialEntryJoin): Promise<TestRecordOfMaterialEntryJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestRecordOfMaterialEntryJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestRecordOfMaterialEntryJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestRecordOfMaterialEntryJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestRecordOfMaterialEntryJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestRecordOfMaterialEntryJoin): Promise<TestRecordOfMaterialEntryJoin>;
    getLastResponse(): any;
}
export declare enum TestSpecificationApiApiKeys {
}
export declare class TestSpecificationApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestSpecificationApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestSpecification): Promise<TestSpecification>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestSpecification>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestSpecification>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestSpecification>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestSpecification>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestSpecification): Promise<TestSpecification>;
    getLastResponse(): any;
}
export declare enum TestSpecificationMaterialTestJoinApiApiKeys {
}
export declare class TestSpecificationMaterialTestJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestSpecificationMaterialTestJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestSpecificationMaterialTestJoin): Promise<TestSpecificationMaterialTestJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestSpecificationMaterialTestJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestSpecificationMaterialTestJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestSpecificationMaterialTestJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestSpecificationMaterialTestJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestSpecificationMaterialTestJoin): Promise<TestSpecificationMaterialTestJoin>;
    getLastResponse(): any;
}
export declare enum TestSpecificationRequirementApiApiKeys {
}
export declare class TestSpecificationRequirementApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestSpecificationRequirementApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestSpecificationRequirement): Promise<TestSpecificationRequirement>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestSpecificationRequirement>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestSpecificationRequirement>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestSpecificationRequirement>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestSpecificationRequirement>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestSpecificationRequirement): Promise<TestSpecificationRequirement>;
    getLastResponse(): any;
}
export declare enum TestSpecificationSetApiApiKeys {
}
export declare class TestSpecificationSetApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestSpecificationSetApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestSpecificationSet): Promise<TestSpecificationSet>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestSpecificationSet>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestSpecificationSet>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestSpecificationSet>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestSpecificationSet>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestSpecificationSet): Promise<TestSpecificationSet>;
    getLastResponse(): any;
}
export declare enum TestSpecificationSetTestJoinApiApiKeys {
}
export declare class TestSpecificationSetTestJoinApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestSpecificationSetTestJoinApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestSpecificationSetTestJoin): Promise<TestSpecificationSetTestJoin>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestSpecificationSetTestJoin>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestSpecificationSetTestJoin>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestSpecificationSetTestJoin>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestSpecificationSetTestJoin>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestSpecificationSetTestJoin): Promise<TestSpecificationSetTestJoin>;
    getLastResponse(): any;
}
export declare enum TestStepApiApiKeys {
}
export declare class TestStepApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: TestStepApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: TestStep): Promise<TestStep>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<TestStep>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<TestStep>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<TestStep>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<TestStep>>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: TestStep): Promise<TestStep>;
    getLastResponse(): any;
}
export declare enum UserApiApiKeys {
}
export declare class UserApi {
    protected _basePath: string;
    protected defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected _lastResponse: any;
    protected _timeout: number;
    protected authentications: {
        'default': Authentication;
    };
    constructor(basePath?: string);
    useQuerystring: boolean;
    basePath: string;
    timeout: number;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: UserApiApiKeys, value: string): void;
    /**
     * Meadow DELETE
     * @param id ID of record
     */
    _delete(id: number): Promise<boolean>;
    /**
     * Check if an email is already in use
     * @param Email
     */
    checkEmail(Email: string): Promise<any>;
    /**
     * Check if a LoginID is already in use
     * @param LoginID
     */
    checkLoginID(LoginID: string): Promise<any>;
    /**
     * Email confirmation link for self-signup user
     * @param EmailConfirmHash Hash code sent in confirmation email
     */
    confirmEmail(EmailConfirmHash: string): Promise<any>;
    /**
     * Meadow COUNT
     */
    count(): Promise<InlineResponse200>;
    /**
     * Meadow COUNT with filter
     * @param filter FBV meadow filter
     */
    countFiltered(filter: string): Promise<InlineResponse200>;
    /**
     * Meadow POST (Create)
     * @param body
     */
    create(body: UserModel): Promise<UserModel>;
    /**
     * User forgot password email with link
     * @param Email
     */
    forgotPassword(Email: string): Promise<any>;
    /**
     * Get Avtive Users list
     */
    getActiveUsers(): Promise<any>;
    /**
     * Send version and last update dates for various
     */
    getSyncIndicator(): Promise<any>;
    /**
     *
     * @param body
     */
    postReadCountQuery(body: QueryRequest): Promise<InlineResponse200>;
    /**
     *
     * @param body
     */
    postReadQuery(body: QueryRequest): Promise<Array<UserModel>>;
    /**
     * Meadow READ
     * @param id ID of record
     */
    read(id: number): Promise<UserModel>;
    /**
     * Meadow READ list
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    reads(begin: number, max: number): Promise<Array<UserModel>>;
    /**
     * Meadow READ filtered list
     * @param filter FBV meadow filter
     * @param begin Beginning (skip) number of records (to page)
     * @param max Maximum number of records to return
     */
    readsFiltered(filter: string, begin: number, max: number): Promise<Array<UserModel>>;
    /**
     * Request to resend confirmation email (user email must not be confirmed yet)
     * @param Email
     */
    resendConfirmationEmail(Email: string): Promise<any>;
    /**
     * User self-signup
     * @param body
     */
    signupUser(body: UserSignupRequest): Promise<any>;
    /**
     * Meadow PUT (Update)
     * @param body
     */
    update(body: UserModel): Promise<UserModel>;
    /**
     * Change user password *
     * @param body
     */
    updatePassword(body: ChangePasswordRequest): Promise<any>;
    getLastResponse(): any;
}
